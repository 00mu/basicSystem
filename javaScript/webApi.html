<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>WEB-API | WEB 前端基础体系梳理</title>
    <meta name="description" content="进化中...">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/basicSystem/assets/css/0.styles.978a8c4c.css" as="style"><link rel="preload" href="/basicSystem/assets/js/app.fe57eed6.js" as="script"><link rel="preload" href="/basicSystem/assets/js/3.40885dd2.js" as="script"><link rel="preload" href="/basicSystem/assets/js/52.7d8bbb55.js" as="script"><link rel="prefetch" href="/basicSystem/assets/js/10.8f192e07.js"><link rel="prefetch" href="/basicSystem/assets/js/11.70ea7752.js"><link rel="prefetch" href="/basicSystem/assets/js/12.aff4d014.js"><link rel="prefetch" href="/basicSystem/assets/js/13.0bf7b953.js"><link rel="prefetch" href="/basicSystem/assets/js/14.965f889e.js"><link rel="prefetch" href="/basicSystem/assets/js/15.54ac762d.js"><link rel="prefetch" href="/basicSystem/assets/js/16.6b7d15a8.js"><link rel="prefetch" href="/basicSystem/assets/js/17.4f9c33ec.js"><link rel="prefetch" href="/basicSystem/assets/js/18.e7829a1b.js"><link rel="prefetch" href="/basicSystem/assets/js/19.a14098a6.js"><link rel="prefetch" href="/basicSystem/assets/js/20.9cdf8898.js"><link rel="prefetch" href="/basicSystem/assets/js/21.52406625.js"><link rel="prefetch" href="/basicSystem/assets/js/22.5a250bd9.js"><link rel="prefetch" href="/basicSystem/assets/js/23.b68348d6.js"><link rel="prefetch" href="/basicSystem/assets/js/24.06a02506.js"><link rel="prefetch" href="/basicSystem/assets/js/25.09a10bf9.js"><link rel="prefetch" href="/basicSystem/assets/js/26.298e26d0.js"><link rel="prefetch" href="/basicSystem/assets/js/27.ba9538a8.js"><link rel="prefetch" href="/basicSystem/assets/js/28.4f67f474.js"><link rel="prefetch" href="/basicSystem/assets/js/29.4bea42c4.js"><link rel="prefetch" href="/basicSystem/assets/js/30.90e696e0.js"><link rel="prefetch" href="/basicSystem/assets/js/31.69c8c548.js"><link rel="prefetch" href="/basicSystem/assets/js/32.5309047d.js"><link rel="prefetch" href="/basicSystem/assets/js/33.5b269816.js"><link rel="prefetch" href="/basicSystem/assets/js/34.90d75a26.js"><link rel="prefetch" href="/basicSystem/assets/js/35.e1f8a67a.js"><link rel="prefetch" href="/basicSystem/assets/js/36.1224f9ef.js"><link rel="prefetch" href="/basicSystem/assets/js/37.514fe7f4.js"><link rel="prefetch" href="/basicSystem/assets/js/38.8691a21e.js"><link rel="prefetch" href="/basicSystem/assets/js/39.43c15237.js"><link rel="prefetch" href="/basicSystem/assets/js/4.616c069e.js"><link rel="prefetch" href="/basicSystem/assets/js/40.341eebc6.js"><link rel="prefetch" href="/basicSystem/assets/js/41.61141311.js"><link rel="prefetch" href="/basicSystem/assets/js/42.096b0e5b.js"><link rel="prefetch" href="/basicSystem/assets/js/43.08c8940b.js"><link rel="prefetch" href="/basicSystem/assets/js/44.972fa1ee.js"><link rel="prefetch" href="/basicSystem/assets/js/45.18b164ae.js"><link rel="prefetch" href="/basicSystem/assets/js/46.c5084eb9.js"><link rel="prefetch" href="/basicSystem/assets/js/47.5a081ac6.js"><link rel="prefetch" href="/basicSystem/assets/js/48.1dfe435d.js"><link rel="prefetch" href="/basicSystem/assets/js/49.9591def2.js"><link rel="prefetch" href="/basicSystem/assets/js/5.75c0cb05.js"><link rel="prefetch" href="/basicSystem/assets/js/50.42d39276.js"><link rel="prefetch" href="/basicSystem/assets/js/51.2ce3513a.js"><link rel="prefetch" href="/basicSystem/assets/js/53.a9481449.js"><link rel="prefetch" href="/basicSystem/assets/js/54.cdf677e4.js"><link rel="prefetch" href="/basicSystem/assets/js/55.19599d18.js"><link rel="prefetch" href="/basicSystem/assets/js/56.f10f47fa.js"><link rel="prefetch" href="/basicSystem/assets/js/57.e3bb2ba8.js"><link rel="prefetch" href="/basicSystem/assets/js/58.4ffe555a.js"><link rel="prefetch" href="/basicSystem/assets/js/59.a549b1ff.js"><link rel="prefetch" href="/basicSystem/assets/js/6.2dd188fc.js"><link rel="prefetch" href="/basicSystem/assets/js/7.6a47198c.js"><link rel="prefetch" href="/basicSystem/assets/js/8.da290d25.js"><link rel="prefetch" href="/basicSystem/assets/js/9.b8c11fc3.js"><link rel="prefetch" href="/basicSystem/assets/js/vendors~docsearch.a3318253.js">
    <link rel="stylesheet" href="/basicSystem/assets/css/0.styles.978a8c4c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/basicSystem/" class="home-link router-link-active"><!----> <span class="site-name">WEB 前端基础体系梳理</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="手稿" class="dropdown-title"><span class="title">手稿</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          基础语法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/basicSystem/basic/HTML/" class="nav-link">
  HTML
</a></li><li class="dropdown-subitem"><a href="/basicSystem/basic/CSS/" class="nav-link">
  CSS
</a></li></ul></li><li class="dropdown-item"><h4>
          MVVM
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/mvvm/VUE/" class="nav-link">
  VUE
</a></li><li class="dropdown-subitem"><a href="/basicSystem/mvvm/React/" class="nav-link">
  React
</a></li><li class="dropdown-subitem"><a href="/basicSystem/mvvm/Electron/" class="nav-link">
  Electron
</a></li></ul></li><li class="dropdown-item"><h4>
          前端工程
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/webpack/" class="nav-link">
  webpack
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/basicSystem/deepLearning/" class="nav-link">
  专题
</a></div><div class="nav-item"><a href="/basicSystem/coding/" class="nav-link">
  Coding
</a></div><div class="nav-item"><a href="/basicSystem/interview/" class="nav-link">
  考点
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          编辑器
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/soft/git.html" class="nav-link">
  GIT
</a></li><li class="dropdown-subitem"><a href="/basicSystem/soft/vscode/" class="nav-link">
  VSCODE
</a></li></ul></li><li class="dropdown-item"><h4>
          效率工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/javaScript/figma.com.html" class="nav-link">
  figma
</a></li></ul></li></ul></div></div> <a href="https://github.com/bbzz/basicSystem" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="手稿" class="dropdown-title"><span class="title">手稿</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          基础语法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/basicSystem/basic/HTML/" class="nav-link">
  HTML
</a></li><li class="dropdown-subitem"><a href="/basicSystem/basic/CSS/" class="nav-link">
  CSS
</a></li></ul></li><li class="dropdown-item"><h4>
          MVVM
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/mvvm/VUE/" class="nav-link">
  VUE
</a></li><li class="dropdown-subitem"><a href="/basicSystem/mvvm/React/" class="nav-link">
  React
</a></li><li class="dropdown-subitem"><a href="/basicSystem/mvvm/Electron/" class="nav-link">
  Electron
</a></li></ul></li><li class="dropdown-item"><h4>
          前端工程
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/webpack/" class="nav-link">
  webpack
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/basicSystem/deepLearning/" class="nav-link">
  专题
</a></div><div class="nav-item"><a href="/basicSystem/coding/" class="nav-link">
  Coding
</a></div><div class="nav-item"><a href="/basicSystem/interview/" class="nav-link">
  考点
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          编辑器
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/soft/git.html" class="nav-link">
  GIT
</a></li><li class="dropdown-subitem"><a href="/basicSystem/soft/vscode/" class="nav-link">
  VSCODE
</a></li></ul></li><li class="dropdown-item"><h4>
          效率工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicSystem/javaScript/figma.com.html" class="nav-link">
  figma
</a></li></ul></li></ul></div></div> <a href="https://github.com/bbzz/basicSystem" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/basicSystem/javaScript/" class="sidebar-link">JavaScript</a></li><li><a href="/basicSystem/javaScript/grammar.html" class="sidebar-link">语法</a></li><li><a href="/basicSystem/javaScript/stdlib.html" class="sidebar-link">标准库</a></li><li><a href="/basicSystem/javaScript/webApi.html" class="active sidebar-link">WEB-API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#dom" class="sidebar-link">DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#node-接口" class="sidebar-link">Node 接口</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#nodelist-接口" class="sidebar-link">NodeList 接口</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#htmlcollection-接口" class="sidebar-link">HTMLCollection 接口</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#parentnode-接口" class="sidebar-link">ParentNode  接口</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#childnode-接口" class="sidebar-link">ChildNode 接口</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#childnode-接口-2" class="sidebar-link">ChildNode 接口</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#document-节点" class="sidebar-link">Document 节点</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#element-节点" class="sidebar-link">Element 节点</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#属性的操作" class="sidebar-link">属性的操作</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#text-节点" class="sidebar-link">Text 节点</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#documentfragment-文档片段节点" class="sidebar-link">DocumentFragment 文档片段节点</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#css-操作" class="sidebar-link">CSS 操作</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#mutation-observer-api" class="sidebar-link">Mutation Observer API</a></li></ul></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#事件" class="sidebar-link">事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#eventtarget-接口" class="sidebar-link">EventTarget 接口</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#事件模型" class="sidebar-link">事件模型</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#event-对象" class="sidebar-link">Event 对象</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#数表事件" class="sidebar-link">数表事件</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#键盘事件" class="sidebar-link">键盘事件</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#进度事件" class="sidebar-link">进度事件</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#表单事件" class="sidebar-link">表单事件</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#触摸事件" class="sidebar-link">触摸事件</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#拖拉事件" class="sidebar-link">拖拉事件</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#其他事件" class="sidebar-link">其他事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#bom" class="sidebar-link">BOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#浏览器环境概述" class="sidebar-link">浏览器环境概述</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#window-对象" class="sidebar-link">window 对象</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#navigator-对象" class="sidebar-link">Navigator 对象</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#screen-对象" class="sidebar-link">Screen 对象</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#cookie" class="sidebar-link">Cookie</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#xmlhttprequest" class="sidebar-link">XMLHttpRequest</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#xmlhttprequest-withcredentials" class="sidebar-link">XMLHttpRequest.withCredentials</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#cookie-storage" class="sidebar-link">cookie storage</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#location" class="sidebar-link">location</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#url" class="sidebar-link">URL</a></li></ul></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#存储" class="sidebar-link">存储</a></li><li class="sidebar-sub-header"><a href="/basicSystem/javaScript/webApi.html#多媒体元素接口" class="sidebar-link">多媒体元素接口</a></li></ul></li><li><a href="/basicSystem/javaScript/ES6.html" class="sidebar-link">ES6+ 简要手册</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="web-api"><a href="#web-api" class="header-anchor">#</a> WEB-API</h1> <p>ECMA为 <code>JavaScript</code> 提供了语法和一些原生的对象库，W3C标准提供了丰富的WEB接口供 <code>JavaScript</code> 来调用在浏览器中进行各种操作。</p> <h2 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h2> <p>“文档对象模型”（Document Object Model），将网页转为一个 JavaScript 对象，将结构化的文档（HTML）解析成一系列节点组成一个树状结构（DOM Tree），所有节点和最终的树状结构都有规范的对外接口，从而可以用脚本进行各种操作。</p> <blockquote><p>节点（node）：DOM的最小组成单位。</p></blockquote> <blockquote><p>节点树（DOM Tree）：树是一种数据结构，根节点、父子节点、同级别节点构成， <code>document</code> 是顶级节点代表整个文档树。</p></blockquote> <h3 id="node-接口"><a href="#node-接口" class="header-anchor">#</a> Node 接口</h3> <h4 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h4> <p>节点的7种类型，都继承了 node, 具有相同的属性和方法。</p> <table><thead><tr><th>节点</th> <th>nodeType</th> <th>nodeName</th> <th>nodeValue</th> <th></th></tr></thead> <tbody><tr><td>文档（document）</td> <td>9</td> <td>#document</td> <td>null</td> <td></td></tr> <tr><td>元素（element）</td> <td>1</td> <td>大写的标签名</td> <td>null</td> <td></td></tr> <tr><td>属性（attr）</td> <td>2</td> <td>属性的名称</td> <td>前节点本身的文本值</td> <td></td></tr> <tr><td>文本（text）</td> <td>3</td> <td>#text</td> <td>前节点本身的文本值</td> <td></td></tr> <tr><td>文档片断（DocumentFragment）</td> <td>11</td> <td>#document-fragment</td> <td>null</td> <td></td></tr> <tr><td>文档类型（DocumentType）</td> <td>10</td> <td>文档的类型</td> <td>null</td> <td></td></tr> <tr><td>注释（Comment）</td> <td>8</td> <td>#comment</td> <td>前节点本身的文本值</td> <td></td></tr></tbody></table> <table><thead><tr><th>其他属性</th> <th>描述</th></tr></thead> <tbody><tr><td>textContent</td> <td>返回当前节点和它的所有后代节点的文本内容，可读写</td></tr> <tr><td>baseURI</td> <td>当前网页的绝对路径(window.location)</td></tr> <tr><td>ownerDocument</td> <td>返回当前节点所在的顶层文档对象，即document对象，document.ownerDocument 为null</td></tr> <tr><td>nextSibling</td> <td>紧跟在当前节点后面的第一个同级节点，没有就返回null，该属性还包括文本节点和注释节点</td></tr> <tr><td>previousSibling</td> <td>当前节点前面的、距离最近的一个同级节点</td></tr> <tr><td>parentNode</td> <td>当前节点的父节点，元素节点、文档节点和文档片段节点其一</td></tr> <tr><td>parentElement</td> <td>当前节点的父元素节点</td></tr> <tr><td>firstChild</td> <td>当前节点的第一个子节点</td></tr> <tr><td>lastChild</td> <td>属性返回当前节点的最后一个子节点</td></tr> <tr><td>childNodes</td> <td>返回一个类似数组的对象（NodeList集合）, 包括当前节点的所有子节点</td></tr> <tr><td>isConnected</td> <td>判断当前节点是否在文档之中，返回布尔值</td></tr></tbody></table> <h4 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h4> <table><thead><tr><th>title</th> <th>title</th></tr></thead> <tbody><tr><td>appendChild()</td> <td>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点；如果参数节点是 DOM 已经存在的节点，appendChild()方法会将其从原来的位置，移动到新位置。</td></tr> <tr><td>hasChildNodes()</td> <td>返回一个布尔值，表示当前节点是否有子节点</td></tr> <tr><td>cloneNode()</td> <td>用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</td></tr> <tr><td>insertBefore()</td> <td>parentNode.insertBefore(newNode, referenceNode), 插入到指定位置，第一个参数是所要插入的节点newNode，第二个参数是父节点parentNode内部的一个子节点referenceNode</td></tr> <tr><td>removeChild()</td> <td>从当前节点移除该子节点，如果参数节点不是当前节点的子节点，removeChild方法将报错</td></tr> <tr><td>replaceChild()</td> <td>div1.parentNode.replaceChild(newChild, div1), 替换当前节点的某一个子节点</td></tr> <tr><td>contains()</td> <td>是否包含参数节点，1. 参数节点为当前节点2. 参数节点为当前节点的子节点3. 参数节点为当前节点的后代节点</td></tr> <tr><td>compareDocumentPosition()</td> <td>用法与contains方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系</td></tr> <tr><td>isEqualNode()</td> <td>返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同</td></tr> <tr><td>isSameNode()</td> <td>表示两个节点是否为同一个节点，相同必然相等，反之则不</td></tr> <tr><td>normalize()</td> <td>用于清理当前节点内部的所有文本节点</td></tr> <tr><td>getRootNode()</td> <td>与ownerDocument属性的作用相同</td></tr></tbody></table> <h3 id="nodelist-接口"><a href="#nodelist-接口" class="header-anchor">#</a> NodeList 接口</h3> <p>NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例</p> <ul><li><code>Node.childNodes</code></li> <li><code>document.querySelectorAll()</code> 等节点搜索方法</li></ul> <p>可以使用length属性和forEach方法。NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合</p> <table><thead><tr><th>属性方法</th> <th>描述</th></tr></thead> <tbody><tr><td>length</td> <td>返回 NodeList 实例包含的节点数量</td></tr> <tr><td>forEach()</td> <td>遍历 NodeList 的所有成员，用法与数组实例的forEach方法完全一致</td></tr> <tr><td>item()</td> <td>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员</td></tr> <tr><td>keys()</td> <td>这三个方法都返回一个 ES6 的遍历器对象，可以通过for... of循环遍历获取每一个成员的信息；返回键名的遍历器</td></tr> <tr><td>values()</td> <td>返回键值的遍历器</td></tr> <tr><td>entries()</td> <td>返回的遍历器同时包含键名和键值的信息</td></tr></tbody></table> <h3 id="htmlcollection-接口"><a href="#htmlcollection-接口" class="header-anchor">#</a> HTMLCollection 接口</h3> <p>是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历。</p> <p>返回HTMLCollection实例的，主要是一些Document对象的集合属性，比如 <code>document.links</code> 、 <code>document.forms</code> 、 <code>document.images</code> 等，见节点集合属性。</p> <p>HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中</p> <table><thead><tr><th>属性方法</th> <th>描述</th></tr></thead> <tbody><tr><td>length</td> <td>返回 HTMLCollection 实例包含的成员数量</td></tr> <tr><td>item()</td> <td>接受一个整数值作为参数，表示成员的位置，返回该位置上的成员</td></tr> <tr><td>namedItem()</td> <td>方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点</td></tr></tbody></table> <h3 id="parentnode-接口"><a href="#parentnode-接口" class="header-anchor">#</a> ParentNode  接口</h3> <p>ParentNode 接口表示当前节点是一个父节点，提供一些处理子节点的方法</p> <table><thead><tr><th>属性方法</th> <th>描述</th></tr></thead> <tbody><tr><td>children()</td> <td>返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读</td></tr> <tr><td>firstElementChild()</td> <td>返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null</td></tr> <tr><td>lastElementChild()</td> <td>返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null</td></tr> <tr><td>childElementCount()</td> <td>返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0</td></tr> <tr><td>append()</td> <td>为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面；不仅可以添加元素子节点，还可以添加文本子节点</td></tr> <tr><td>prepend()</td> <td>为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面；不仅可以添加元素子节点，还可以添加文本子节点</td></tr></tbody></table> <h3 id="childnode-接口"><a href="#childnode-接口" class="header-anchor">#</a> ChildNode 接口</h3> <p>如果一个节点有父节点，那么该节点就拥有了ChildNode接口。</p> <table><thead><tr><th>属性方法</th> <th>描述</th></tr></thead> <tbody><tr><td>el.remove()</td> <td>从父节点移除当前节点</td></tr> <tr><td>el.defore(a, b)</td> <td>用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点</td></tr> <tr><td>el.after(a, b)</td> <td>用于在当前节点的后面，插入一个或多个同级节点。两者拥有相同的父节点</td></tr> <tr><td>el.replaceWith(a)</td> <td>用参数节点，替换当前节点</td></tr></tbody></table> <h3 id="childnode-接口-2"><a href="#childnode-接口-2" class="header-anchor">#</a> ChildNode 接口</h3> <p>ChildNode 接口表示当前节点是一个子节点，提供一些相关方法</p> <h3 id="document-节点"><a href="#document-节点" class="header-anchor">#</a> Document 节点</h3> <p>document节点对象代表整个文档，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p> <p>document对象有不同的办法可以获取。</p> <ul><li>正常的网页，直接使用document或window.document。</li> <li>iframe框架里面的网页，使用iframe节点的contentDocument属性。</li> <li>Ajax 操作返回的文档，使用XMLHttpRequest对象的responseXML属性。</li> <li>内部节点的ownerDocument属性。</li></ul> <p>document对象继承了EventTarget接口和Node接口，并且混入（mixin）了ParentNode接口。这意味着，这些接口的方法都可以在document对象上调用。除此之外，document对象还有很多自己的属性和方法。</p> <h4 id="document-属性"><a href="#document-属性" class="header-anchor">#</a> Document 属性</h4> <table><thead><tr><th>属性</th> <th>描述</th></tr></thead> <tbody><tr><td>快捷属性</td> <td>指向文档内部的某个节点的快捷方式</td></tr> <tr><td>document.defaultView</td> <td>返回document对象所属的window对象</td></tr> <tr><td>document.doctype</td> <td>指向 <code>&lt;DOCTYPE&gt;</code> 节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成 <code>&lt;!DOCTYPE html&gt;</code></td></tr> <tr><td>document.documentElement</td> <td>指向 <code>&lt;html&gt;</code> 节点</td></tr> <tr><td>document.body</td> <td>指向 <code>&lt;body&gt;</code> 节点</td></tr> <tr><td>document.head</td> <td>指向 <code>&lt;head&gt;</code> 节点</td></tr> <tr><td>document.scrollingElement</td> <td>返回文档的滚动元素。滚动到顶部 <code>document.scrollingElement.scrollTop = 0</code></td></tr> <tr><td>document.activeElement</td> <td>返回获得当前焦点（focus）的 DOM 元素，通常，这个属性返回的是 <code>&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;</code> 等表单元素，如果当前没有焦点元素，返回 <code>&lt;body&gt;</code> 元素或null</td></tr> <tr><td>document.fullscreenElement</td> <td>返回document对象所属的window对象</td></tr> <tr><td>document.defaultView</td> <td>返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null</td></tr> <tr><td>节点集合属性</td> <td>处了document.styleSheets返回一个HTMLCollection实例 ，表示文档内部特定元素的集合</td></tr> <tr><td>document.links</td> <td>返回当前文档所有设定了href属性的 <code>&lt;a&gt;</code> 及 <code>&lt;area&gt;</code> 节点</td></tr> <tr><td>document.forms</td> <td>所有 <code>&lt;form&gt;</code> 表单节点</td></tr> <tr><td>document.images</td> <td>所有 <code>&lt;img&gt;</code> 图片节点</td></tr> <tr><td>document.embeds</td> <td>和document.plugins属性，都返回所有 <code>&lt;embed&gt;</code> 节点</td></tr> <tr><td>document.scripts</td> <td>返回所有 <code>&lt;script&gt;</code> 节点</td></tr> <tr><td>document.styleSheets</td> <td>返回文档内嵌或引入的样式表集合</td></tr> <tr><td>静态信息属性</td> <td></td></tr> <tr><td>document.documentURI</td> <td>当前文档的网址，继承自Document接口，可用于所有文档</td></tr> <tr><td>document. URL</td> <td>当前文档的网址，继承自HTMLDocument接口，只能用于 HTML 文档</td></tr> <tr><td>document.document.domain</td> <td>返回当前文档的域名，不包含协议和端口</td></tr> <tr><td>document.document.location</td> <td>浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象</td></tr> <tr><td>document.lastModified</td> <td>返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的</td></tr> <tr><td>document.title</td> <td>返回当前文档的标题。默认情况下，返回 <code>&lt;title&gt;</code> 节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值</td></tr> <tr><td>document.characterSet</td> <td>当前文档的编码，比如UTF-8、ISO-8859-1等等</td></tr> <tr><td>document.referrer</td> <td>返回一个字符串，表示当前文档的访问者来自哪里，</td></tr> <tr><td>document.compatMode</td> <td>返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）；如果网页代码的第一行设置了明确的DOCTYPE（比如&lt;!doctype html&gt;），document.compatMode的值都为CSS1Compat</td></tr> <tr><td>文档状态属性</td> <td></td></tr> <tr><td>document.hidden</td> <td>返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true</td></tr> <tr><td>document.document.visibilityState</td> <td>返回文档的可见状态:1.visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。 2.hidden：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。3.prerender：页面处于正在渲染状态，对于用户来说，该页面不可见。4.unloaded：页面从内存里面卸载了</td></tr> <tr><td>document.readyState</td> <td>浏览器开始解析 HTML 文档，document.readyState属性等于loading。浏览器遇到 HTML 文档中的 <code>&lt;script&gt;</code> 元素，并且没有async或defer属性，就暂停解析，开始执行脚本，这时document.readyState属性还是等于loading。HTML 文档解析完成，document.readyState属性变成interactive。浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，document.readyState属性变成complete。每次都会触发一个readystatechange事件。</td></tr> <tr><td>document.cookie</td> <td>用来操作浏览器 Cookie</td></tr> <tr><td>document.implementation</td> <td>该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。DOMImplementation.createDocument()：创建一个 XML 文档。DOMImplementation.createHTMLDocument()：创建一个 HTML 文档。DOMImplementation.createDocumentType()：创建一个 DocumentType 对象。</td></tr></tbody></table> <h4 id="document-方法"><a href="#document-方法" class="header-anchor">#</a> Document 方法</h4> <table><thead><tr><th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>querySelector 系列</td> <td></td></tr> <tr><td>document.querySelector()</td> <td>接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点</td></tr> <tr><td>document.querySelectorAll()</td> <td>与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。两个方法都支持多个及复杂选择器。All的返回结果<strong>不是动态集合</strong>，不会实时反映元素节点的变化。</td></tr> <tr><td>getElement 系列</td> <td>getElements 返回结果是数组，是动态的</td></tr> <tr><td>document.getElementsByTagName()</td> <td>返回符合条件的所有元素，可以实时反映 HTML 文档的变化</td></tr> <tr><td>document.getElementsByClassName()</td> <td>返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中</td></tr> <tr><td>document.getElementsByName()</td> <td>也是一个集合，拥有name属性的 HTML 元素</td></tr> <tr><td>document.getElementById()</td> <td>匹配指定id属性的元素节点，document.getElementById()比document.querySelector()效率高得多</td></tr> <tr><td>create 系列</td> <td>生成节点</td></tr> <tr><td>document.createTextNode()</td> <td>法用来生成文本节点</td></tr> <tr><td>document.createAttribute()</td> <td>法用来生成属性节点</td></tr> <tr><td>document.createComment()</td> <td>法用来生成注释节点</td></tr> <tr><td>document.createDocumentFragment()</td> <td>生成一个空的文档片段对象， 是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现</td></tr> <tr><td>document.createEvent()</td> <td>生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件</td></tr> <tr><td></td> <td></td></tr> <tr><td>document.hasFocus()</td> <td>当前文档之中是否有元素被激活或获得焦点</td></tr> <tr><td>document.createAttribute()</td> <td>法用来生成属性节点</td></tr> <tr><td>document.createAttribute()</td> <td>法用来生成属性节点</td></tr> <tr><td></td> <td></td></tr> <tr><td>document.open()</td> <td>方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容</td></tr> <tr><td>ocument.close()</td> <td>用来关闭document.open()打开的文档</td></tr> <tr><td>document.write()</td> <td>方法用于向当前文档写入内容, 会当作 HTML 代码解析，不会转义。推荐使用对innerHTML属性赋值</td></tr> <tr><td>document.writeln()</td> <td>与write方法完全一致，除了会在输出内容的尾部添加换行符</td></tr></tbody></table> <h3 id="element-节点"><a href="#element-节点" class="header-anchor">#</a> Element 节点</h3> <p>每一个 HTML 元素，在 DOM 树上都会转化成一个Element节点对象（以下简称元素节点）。Element对象继承了Node接口，因此Node的属性和方法在Element对象都存在。此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如 <code>&lt;a&gt;</code> 元素的节点对象由HTMLAnchorElement构造函数生成， <code>&lt;button&gt;</code> 元素的节点对象由HTMLButtonElement构造函数生成。因此，元素节点不是一种对象，而是一组对象，这些对象除了继承Element的属性和方法，还有各自构造函数的属性和方法。</p> <p>属性和方法太多了，挑拣一些写一下。</p> <h4 id="实例属性"><a href="#实例属性" class="header-anchor">#</a> 实例属性</h4> <table><thead><tr><th>title</th> <th>title</th></tr></thead> <tbody><tr><td>元素特性</td> <td></td></tr> <tr><td>id, tagName, accessKey, draggable, lang, tabIndex, title</td> <td>获取或者改写元素的id、标签、快捷键啊什么的</td></tr> <tr><td>元素状态的相关</td> <td></td></tr> <tr><td>el.hidden</td> <td>控制当前元素是否可见，并不能读取css设置不可见</td></tr> <tr><td>el.contentEditable</td> <td>素可以设置contentEditable属性，使得元素的内容可以编辑</td></tr> <tr><td>el.attributes</td> <td></td></tr> <tr><td>el.className，el.classList</td> <td></td></tr> <tr><td>el.dataset</td> <td></td></tr> <tr><td>el.innerHTML</td> <td>返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括 <code>&lt;HTML&gt;</code> 和 <code>&lt;body&gt;</code> 元素，有安全风险，如果是文本最好使用 textContent</td></tr> <tr><td>el.outerHTML</td> <td></td></tr> <tr><td>el.clientHeight，el.clientWidth</td> <td>返回块级元素的CSS宽高（包括padding，减去滚动条），如果css设置了高度则为设置的值否则为实际块的宽高，document.documentElement.clientHeight 浏览器窗口的高度(不包含滚动条，window.innerHeight 包括滚动条)，document.body.clientHeight 页面文档流的实际高度</td></tr> <tr><td>el.clientLeft，el.clientTop</td> <td>返回左边框、右边框的css大小</td></tr> <tr><td>el.scrollHeight，el.scrollWidth</td> <td>当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括padding，但是不包括border、margin以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度，只可读，整张网页的总高度可以从document.documentElement或document.body上读取</td></tr> <tr><td>el.scrollLeft，el.scrollTop</td> <td>当前元素的水平滚动条向右侧滚动的像素数量，整张网页用document.documentElement.scrollLeft</td></tr> <tr><td>el.offsetParent</td> <td></td></tr> <tr><td>el.offsetHeight，el.offsetWidth</td> <td>包括border和padding和滚动条</td></tr> <tr><td>el.offsetLeft，el.offsetTop</td> <td>相对于父节（position）点的位移</td></tr> <tr><td>el.style</td> <td>每个元素节点都有style用来读写该元素的行内样式信息</td></tr> <tr><td>el.children，el.childelCount</td> <td></td></tr> <tr><td>el.firstelChild，el.lastelChild</td> <td></td></tr> <tr><td>el.nextelSibling，el.previouselSibling</td> <td></td></tr></tbody></table> <h4 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h4> <p>补充几个常见的。</p> <table><thead><tr><th>title</th> <th>title</th></tr></thead> <tbody><tr><td>el.scrollIntoView()</td> <td>滚动当前元素，进入浏览器的可见区域。参数默认true：顶部对齐, false 底部对齐</td></tr> <tr><td>el.getBoundingClientRect()</td> <td>提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息</td></tr> <tr><td>el.getClientRects()</td> <td>返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形。对于行内元素就是多个矩形了</td></tr></tbody></table> <ul><li>el.getBoundingClientRect()，方法的所有属性，都把边框（border属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，width和height包括了元素本身 + padding + border
<ul><li>x：元素左上角相对于视口的横坐标</li> <li>y：元素左上角相对于视口的纵坐标</li> <li>height：元素高度</li> <li>width：元素宽度</li> <li>left：元素左上角相对于视口的横坐标，与x属性相等</li> <li>right：元素右边界相对于视口的横坐标（等于x + width）</li> <li>top：元素顶部相对于视口的纵坐标，与y属性相等</li> <li>bottom：元素底部相对于视口的纵坐标（等于y + height）</li> <li>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将left属性加上window.scrollX，top属性加上window.scrollY</li></ul></li></ul> <h3 id="属性的操作"><a href="#属性的操作" class="header-anchor">#</a> 属性的操作</h3> <p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如onClick</p> <ul><li>Element.attributes 属性</li> <li>元素的标准属性</li> <li>Element.getAttribute()</li> <li>Element.getAttributeNames()</li> <li>Element.setAttribute()</li> <li>Element.hasAttribute()</li> <li>Element.hasAttributes()</li> <li>Element.removeAttribute()</li> <li>dataset 属性</li></ul> <h3 id="text-节点"><a href="#text-节点" class="header-anchor">#</a> Text 节点</h3> <p>Text 节点的概念
Text 节点的属性
data
wholeText
length
nextElementSibling，previousElementSibling
Text 节点的方法
appendData()，deleteData()，insertData()，replaceData()，subStringData()
remove()
splitText()</p> <h3 id="documentfragment-文档片段节点"><a href="#documentfragment-文档片段节点" class="header-anchor">#</a> DocumentFragment 文档片段节点</h3> <p>DocumentFragment节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，parentNode返回null，但是可以插入任意数量的子节点。它不属于当前文档，操作DocumentFragment节点，要比直接操作 DOM 树快得多。</p> <p>注意，DocumentFragment节点本身不能被插入当前文档。当它作为appendChild()、insertBefore()、replaceChild()等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦DocumentFragment节点被添加进当前文档，它自身就变成了空节点（textContent属性为空字符串），可以被再次使用。如果想要保存DocumentFragment节点的内容，可以使用cloneNode方法。</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token comment">// 反转指点节点的所有子节点</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> f <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span> f<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="css-操作"><a href="#css-操作" class="header-anchor">#</a> CSS 操作</h3> <p>如何通过 JavaScript 操作 CSS。</p> <h4 id="html-元素的-style-属性"><a href="#html-元素的-style-属性" class="header-anchor">#</a> HTML 元素的 style 属性</h4> <p>操作 CSS 样式最简单的方法，就是使用网页元素节点的getAttribute()方法、setAttribute()方法和removeAttribute()方法，直接读写或删除网页元素的style属性</p> <div class="language-JS extra-class"><pre class="language-js"><code>div<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>
    <span class="token string">'style'</span><span class="token punctuation">,</span>
    <span class="token string">'background-color:red;'</span> <span class="token operator">+</span> <span class="token string">'border:1px solid black;'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="cssstyledeclaration-接口"><a href="#cssstyledeclaration-接口" class="header-anchor">#</a> CSSStyleDeclaration 接口</h4> <p>CSSStyleDeclaration 接口可以直接读写 CSS 的样式属性。style属性是一个 CSSStyleDeclaration 的实例，对象所包含的属性与 CSS 规则一一对应。写法需要遵循一定的规则：</p> <div class="language-JS extra-class"><pre class="language-js"><code>el<span class="token punctuation">.</span>divStyle<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>连词号需要变成骆驼拼写法，如 background-color写成backgroundColor</li> <li>CSS 属性名是 JavaScript 保留字，则规则名之前需要加上字符串css，比如float写成cssFloat</li> <li>该对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号</li></ul> <h4 id="css-模块的侦测"><a href="#css-模块的侦测" class="header-anchor">#</a> CSS 模块的侦测</h4> <p>有时候，需要知道当前浏览器是否支持某个模块。一个比较普遍适用的方法是，判断元素的style对象的某个属性值是否为字符串。</p> <div class="language-JS extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">[</span><span class="token string">'maxWidth'</span><span class="token punctuation">]</span> <span class="token comment">// &quot;&quot;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">[</span><span class="token string">'maximumWidth'</span><span class="token punctuation">]</span> <span class="token comment">// undefined; 不支持</span>
</code></pre></div><p>一个兼容不同浏览器前缀的函数</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isPropertySupported</span><span class="token punctuation">(</span><span class="token parameter">property</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>property <span class="token keyword">in</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prefixes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Moz'</span><span class="token punctuation">,</span> <span class="token string">'Webkit'</span><span class="token punctuation">,</span> <span class="token string">'O'</span><span class="token punctuation">,</span> <span class="token string">'ms'</span><span class="token punctuation">,</span> <span class="token string">'Khtml'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prefProperty <span class="token operator">=</span> property<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> property<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prefixes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prefixes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> prefProperty<span class="token punctuation">)</span> <span class="token keyword">in</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">isPropertySupported</span><span class="token punctuation">(</span><span class="token string">'background-clip'</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="css-supports-display-table-cell-是否支持某一规则"><a href="#css-supports-display-table-cell-是否支持某一规则" class="header-anchor">#</a> CSS.supports('display: table-cell') 是否支持某一规则</h4> <h4 id="window-getcomputedstyle-用来返回浏览器计算后得到的最终全部规则。"><a href="#window-getcomputedstyle-用来返回浏览器计算后得到的最终全部规则。" class="header-anchor">#</a> window.getComputedStyle() 用来返回浏览器计算后得到的最终全部规则。</h4> <p>它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的各种CSS规则叠加后的最终样式信息。</p> <div class="language-JS extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>documment<span class="token punctuation">.</span>body<span class="token punctuation">)</span>
window<span class="token punctuation">.</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>div<span class="token punctuation">,</span> <span class="token string">':before'</span><span class="token punctuation">)</span> <span class="token comment">// 还可以接受第二个参数，表示当前元素的伪元素（比如:before、:after、:first-line、:first-letter等） </span>
</code></pre></div><h3 id="mutation-observer-api"><a href="#mutation-observer-api" class="header-anchor">#</a> Mutation Observer API</h3> <p>Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p> <p>Mutation Observer 有以下特点。</p> <p>它等待所有脚本任务完成后，才会运行（即异步触发方式）。
它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。
它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</p> <h2 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h2> <h3 id="eventtarget-接口"><a href="#eventtarget-接口" class="header-anchor">#</a> EventTarget 接口</h3> <p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。</p> <p>DOM 事件的操作（监听和触发）都定义在 EventTarget 接口，所有节点都部署了这个接口。提供了三个实例方法。</p> <h4 id="eventtarget-addeventlistener-type-listener-usecapture"><a href="#eventtarget-addeventlistener-type-listener-usecapture" class="header-anchor">#</a> EventTarget.addEventListener(type, listener[, useCapture])</h4> <ul><li>type: 事件名称，大小写敏感</li> <li>listener： 监听函数</li> <li>useCapture：布尔值，默认为false 在冒泡阶段触发； true 在捕获阶段触发
<ul><li>capture：布尔值，表示该事件是否在捕获阶段触发监听函数。</li> <li>once：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li> <li>passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li></ul></li></ul> <div class="language-JS extra-class"><pre class="language-js"><code>el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>addEventListener方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。</li> <li>如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除</li></ul> <h4 id="eventtarget-removeeventlistener"><a href="#eventtarget-removeeventlistener" class="header-anchor">#</a> EventTarget.removeEventListener()</h4> <p>参数，与addEventListener方法完全一致，才能移除。</p> <h4 id="eventtarget-dispatchevent"><a href="#eventtarget-dispatchevent" class="header-anchor">#</a> EventTarget.dispatchEvent()</h4> <p>在当前节点上触发指定事件，从而触发监听函数的执行。自定义事件用起来。</p> <p>该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。</p> <p>dispatchEvent方法的参数是一个Event对象的实例。</p> <p>根据dispatchEvent方法的返回值，判断事件是否被取消了。</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">var</span> canceled <span class="token operator">=</span> <span class="token operator">!</span>cb<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>canceled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'事件取消'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'事件未取消'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="事件模型"><a href="#事件模型" class="header-anchor">#</a> 事件模型</h3> <p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。这是事件驱动编程模式（event-driven）的主要编程方式。</p> <p>DOM 0级的监听方式：</p> <div class="language-JS extra-class"><pre class="language-js"><code>el<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>DOM 2级的监听方式：</p> <div class="language-JS extra-class"><pre class="language-js"><code>el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><p>DOM0，缺点在于同一事件只能定义一个监听函数，多次定义后面覆盖前面的。</p> <p>DOM2（DOM1没有规定事件相关规范），是推荐的优点如下：</p> <ul><li>同一事件可以添加多个监听函数</li> <li>能够指定在冒泡还是捕获阶段触发（先捕获，再冒泡）</li> <li>除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li></ul> <h4 id="this指向"><a href="#this指向" class="header-anchor">#</a> this指向</h4> <p>监听函数内部的this指向触发事件的那个元素节点。</p> <h4 id="事件的传播"><a href="#事件的传播" class="header-anchor">#</a> 事件的传播</h4> <ul><li>第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li> <li>第二阶段：在目标节点(点击触发最底层的那个节点)上触发，称为“目标阶段”（target phase）。</li> <li>第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li></ul> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token comment">// html 结构</span>
html <span class="token operator">&gt;</span> body <span class="token operator">&gt;</span> p

<span class="token keyword">const</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'P'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>捕获阶段 window&gt;html&gt;body&gt;p</li> <li>目标阶段 p（会触发两次）</li> <li>冒泡阶段 p&gt;body&gt;html&gt;window</li></ol> <h4 id="事件的代理"><a href="#事件的代理" class="header-anchor">#</a> 事件的代理</h4> <p>由于事件会冒泡到父节点上，因此可以把子节点的监听函数定义在父节点上，由父节点同一处理子元素的事件。这种方法称之为代理。</p> <p>好处有2：1. 代码更简洁，2. 不用给新增加的子元素绑定事件</p> <p>阻止事件传播</p> <ul><li>event.stopPropagation  阻止事件传播</li> <li>event.stopImmediatePropagation  不再触发后面所有click的监听函数</li></ul> <h3 id="event-对象"><a href="#event-对象" class="header-anchor">#</a> Event 对象</h3> <p>事件发生后会产生一个事件对象作为参数传递给监听函数，所有事件对象都是原生 Event 的实例。</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token comment">// 生成一个事件对象</span>
<span class="token keyword">const</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// type 是事件名，是个字符串</span>
<span class="token comment">// options 事件对象的配置项，是可选项。它有两个属性，配置如下：</span>
<span class="token punctuation">{</span>
    bubbles<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 表示事件对象是否冒泡，默认false 不冒泡只能在捕获阶段触发</span>
    cancelable<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">// 事件是否可以被Event.preventDefault()取消，默认false 不可以 </span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="实例属性-2"><a href="#实例属性-2" class="header-anchor">#</a> 实例属性</h4> <table><thead><tr><th>实例属性</th> <th>描述</th></tr></thead> <tbody><tr><td>Event.bubbles</td> <td>返回布尔值，判断事件是否可以冒泡</td></tr> <tr><td>Event.eventPhase</td> <td>返回一个数字，表示目前处于哪个阶段：<br>0 -&gt; 事件没有发生<br>1 -&gt; 捕获阶段<br>2 -&gt; 目标节点<br>3 -&gt; 冒泡阶段</td></tr> <tr><td>Event.cancelable</td> <td>事件是否可以取消</td></tr> <tr><td>Event.cancelBubble</td> <td>属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播</td></tr> <tr><td>Event.defaultPrevented</td> <td>返回一个布尔值，表示该事件是否调用过Event.preventDefault方法</td></tr> <tr><td>Event.cancelable</td> <td>返回一个布尔值，表示该事件是否调用过</td></tr> <tr><td>Event.target</td> <td>事件的原始触发节点（比如click，就是直接点击的哪个最底层的节点）</td></tr> <tr><td>Event.currentTarget</td> <td>事件当前正在通过的节点，随着事件捕获或者冒泡传播属性值会变化，事件对象中的 this 指向 事件的currentTarget属性</td></tr> <tr><td>Event.type</td> <td>事件的属性类型</td></tr> <tr><td>Event.timeStamp</td> <td>返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的</td></tr> <tr><td>Event.isTrusted</td> <td>返回一个布尔值，表示该事件是否由真实的用户行为产生。Event构造函数生成的事件返回false，因为是脚本产生的</td></tr> <tr><td>Event.detail</td> <td>返回一个数值表示事件的某种信息，具体和事件类型有关，比如click 1单机 2双击</td></tr></tbody></table> <h4 id="实例方法-2"><a href="#实例方法-2" class="header-anchor">#</a> 实例方法</h4> <table><thead><tr><th>实例方法</th> <th>描述</th></tr></thead> <tbody><tr><td>Event.preventDefault()</td> <td>只是阻止当前元素的默认事件，不会阻止传播；<br>该方法生效的前提是，事件对象的cancelable属性为true</td></tr> <tr><td>Event.stopPropagation()</td> <td>阻止当前事件的继续传播，但不会阻止当前节点其他事件监听函数</td></tr> <tr><td>Event.stopImmediatePropagation()</td> <td>阻止当前事件的继续传播，同时阻止当前节点在其之后的事件监听</td></tr> <tr><td>Event.composedPath()</td> <td>返回一个数组，成员是最底层节点和依次经过的所有上层节点，比如['button',...,'body', 'html', 'window']</td></tr></tbody></table> <p>事件太多了，业务中用到再查，建议参考阮一峰老师的教程 <a href="https://wangdoc.com/javascript/events/index.html" target="_blank" rel="noopener noreferrer">事件一览表<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="数表事件"><a href="#数表事件" class="header-anchor">#</a> 数表事件</h3> <h3 id="键盘事件"><a href="#键盘事件" class="header-anchor">#</a> 键盘事件</h3> <h3 id="进度事件"><a href="#进度事件" class="header-anchor">#</a> 进度事件</h3> <h3 id="表单事件"><a href="#表单事件" class="header-anchor">#</a> 表单事件</h3> <h3 id="触摸事件"><a href="#触摸事件" class="header-anchor">#</a> 触摸事件</h3> <h3 id="拖拉事件"><a href="#拖拉事件" class="header-anchor">#</a> 拖拉事件</h3> <h3 id="其他事件"><a href="#其他事件" class="header-anchor">#</a> 其他事件</h3> <ul><li>资源事件
<ul><li>beforeunload 事件</li> <li>unload 事件</li> <li>load 事件，error 事件</li></ul></li> <li>session 历史事件
<ul><li>pageshow 事件，pagehide 事件</li> <li>popstate 事件</li> <li>hashchange 事件</li></ul></li> <li>网页状态事件
<ul><li>DOMContentLoaded 事件 ： DOM 一解析完毕就会在document对象上触发 DOMContentLoaded 事件</li> <li>readystatechange 事件</li></ul></li> <li>窗口事件
<ul><li>scroll 事件</li> <li>resize 事件</li> <li>fullscreenchange 事件，fullscreenerror 事件</li></ul></li> <li>剪贴板事件</li> <li>焦点事件</li> <li>CustomEvent 接口 用于自定义事件传递数据</li></ul> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">var</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span><span class="token string">'build'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">'detail'</span><span class="token operator">:</span> <span class="token string">'hello'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">eventHandler</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'build'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="bom"><a href="#bom" class="header-anchor">#</a> BOM</h2> <p>浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。</p> <h3 id="浏览器环境概述"><a href="#浏览器环境概述" class="header-anchor">#</a> 浏览器环境概述</h3> <h4 id="javascript-嵌入页面的4中方法"><a href="#javascript-嵌入页面的4中方法" class="header-anchor">#</a> JavaScript 嵌入页面的4中方法</h4> <ul><li><code>&lt;script&gt;</code>元素直接嵌入代码。</li> <li><code>&lt;script&gt;</code>标签加载外部脚本</li> <li>事件属性</li> <li>URL 协议</li></ul> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">&quot;javascript: new Date().toLocaleTimeString();void 0;&quot;</span><span class="token operator">&gt;</span>点击<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>
<span class="token comment">// javascript:协议的常见用途是书签脚本 Bookmarklet</span>
</code></pre></div><h4 id="script-元素的工作原理"><a href="#script-元素的工作原理" class="header-anchor">#</a> <code>&lt;script&gt;</code> 元素的工作原理</h4> <ol><li>一边下载HTML同时开始解析</li> <li>解析过程中遇到 <code>&lt;script&gt;</code> 元素，就暂停解析，把网页渲染控制权交给 JavaScript 引擎。</li> <li>如果<code>&lt;script&gt;</code>引用了外部脚本就去下载，否则开始执行脚本</li> <li>执行完毕脚本，JavaScript 引擎将控制权交给渲染引擎，继续解析html</li></ol> <p>so, 基本资源放置在body是比较好的方法，另外为了尽快执行脚本 使用 DOMContentLoaded 事件回调，因为在DOM渲染已结束就触发</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
      <span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span>
      <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><div class="language-JS extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;a.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;b.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token comment">// 多个js可能并行加载，尽管可能b先加载完，依然需要等待a加载结束先执行a再执行b</span>
<span class="token comment">// 另外，同域名请求打开tcp连接数量有限制，而请求不同域名没有限制</span>
</code></pre></div><p>解决阻塞加载的两个属性：defer &amp; async</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token comment">// defer</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;a.js&quot;</span> defer<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;b.js&quot;</span> defer<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 浏览器在解析html过程中发现带有defer属性的`&lt;script&gt;`元素，继续向下解析同时下载脚本，</span>
<span class="token comment">// 完成解析后开始执行加载的脚本，在 DOMContentLoaded 事件触发前加载</span>
<span class="token comment">// 不影响a，b执行的顺序</span>

<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;a.js&quot;</span> async<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;b.js&quot;</span> async<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 不同的是，谁先下载完，先执行谁</span>
<span class="token comment">// 相比 defer 第一个文件可能执行的更早， 但是不保证执行顺序</span>
</code></pre></div><p>加载协议：</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;example.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>  <span class="token comment">// 默认http协议下载</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;https://example.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span> <span class="token comment">// 指定https下载</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;//example.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span> <span class="token comment">// 根据页面本身的协议决定加载协议</span>
</code></pre></div><p>渲染引擎：</p> <ul><li>不同浏览器使用不用引擎</li> <li>Firefox：Gecko 引擎</li> <li>Safari：WebKit 引擎</li> <li>Chrome：Blink 引擎</li> <li>IE: Trident 引擎</li> <li>Edge: EdgeHTML 引擎</li></ul> <p>渲染有4个阶段，</p> <ol><li>解析代码： HTML -&gt; DOM，CSS -&gt; CSSOM</li> <li>对象合成：将DOM 和 CSSOM 合成一颗渲染树</li> <li>flow：计算布局，各个节点大小位置等</li> <li>paint：绘制</li></ol> <p>重排（reflow）：渲染引擎计算元素位置和大小时会引起重排</p> <p>重绘（repaint）：将重排的结果或者元素颜色等信息都会引起重新渲染，重排必然重绘</p> <p>JavaScript 引擎：在 eventLoop 详细解释</p> <h3 id="window-对象"><a href="#window-对象" class="header-anchor">#</a> window 对象</h3> <ol><li><p>概述</p></li> <li><p>window 对象的属性</p> <ol><li>window.name</li> <li>window.closed，window.opener</li> <li>window.self，window.window</li> <li>window.frames，window.length</li> <li>window.frameElement</li> <li>window.top，window.parent</li> <li>window.status</li> <li>window.devicePixelRatio</li> <li>位置大小属性</li> <li>组件属性</li> <li>全局对象属性</li></ol></li> <li><p>window.isSecureContext</p> <ol><li>window 对象的方法</li> <li>window.alert()，window.prompt()，window.confirm()</li> <li>window.open(), window.close()，window.stop()</li> <li>window.moveTo()，window.moveBy()</li> <li>window.resizeTo()，window.resizeBy()</li> <li>window.scrollTo()，window.scroll()，window.scrollBy()</li></ol> <div class="language-JS extra-class"><pre class="language-js"><code>  window<span class="token punctuation">.</span><span class="token function">scrollTo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    top<span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>
    behavior<span class="token operator">:</span> <span class="token string">'smooth'</span> <span class="token comment">// 丝滑细腻的滚动</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//如果不是要滚动整个文档，而是要滚动某个元素</span>
  Element<span class="token punctuation">.</span>scrollTop
  Element<span class="token punctuation">.</span>scrollLeft
  Element<span class="token punctuation">.</span><span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ol><li>window.print()</li> <li>window.focus()，window.blur()</li> <li>window.getSelection()</li> <li>window.getComputedStyle()，window.matchMedia()</li> <li>window.requestAnimationFrame()</li> <li>window.requestIdleCallback()</li></ol></li> <li><p>事件</p> <ol><li>load 事件和 onload 属性</li> <li>error 事件和 onerror 属性</li> <li>window 对象的事件监听属性</li></ol></li> <li><p>多窗口操作</p> <ol><li>窗口的引用</li> <li>iframe 元素</li> <li>window.frames 属性</li></ol></li></ol> <h3 id="navigator-对象"><a href="#navigator-对象" class="header-anchor">#</a> Navigator 对象</h3> <p>属性：</p> <ul><li>Navigator.userAgent：最长用了 ua</li> <li>Navigator.plugins</li> <li>Navigator.platform ： 返回用户的操作系统信息</li> <li>Navigator.onLine ： 是否联网</li> <li>Navigator.language，Navigator.languages</li> <li>Navigator.geolocation</li> <li>Navigator.cookieEnabled</li></ul> <p>方法：</p> <ul><li>Navigator.javaEnabled()：否能运行 Java Applet 小程序</li> <li>Navigator.sendBeacon()：用于向服务器异步发送数据</li></ul> <h3 id="screen-对象"><a href="#screen-对象" class="header-anchor">#</a> Screen 对象</h3> <ul><li>Screen.height：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。</li> <li>Screen.width：浏览器窗口所在的屏幕的宽度（单位像素）。</li> <li>Screen.availHeight：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于height减去那些被系统组件的高度。</li> <li>Screen.availWidth：浏览器窗口可用的屏幕宽度（单位像素）。</li> <li>Screen.pixelDepth：整数，表示屏幕的色彩位数，比如24表示屏幕提供24位色彩。</li> <li>Screen.colorDepth：Screen.pixelDepth的别名。严格地说，colorDepth 表示应用程序的颜色深度，pixelDepth 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。</li> <li>Screen.orientation：返回一个对象，表示屏幕的方向。该对象的type属性是一个字符串，表示屏幕的具体方向，landscape-primary表示横放，landscape-secondary表示颠倒的横放，portrait-primary表示竖放，portrait-secondary。</li></ul> <h3 id="cookie"><a href="#cookie" class="header-anchor">#</a> Cookie</h3> <p>cookie 是前后端通信http协议的一部分，每次请求都会携带cookie。</p> <h3 id="xmlhttprequest"><a href="#xmlhttprequest" class="header-anchor">#</a> XMLHttpRequest</h3> <p>用脚本发起的通信，就可以叫Ajax。创建一个Ajax：</p> <ol><li>创建一个 XMLHttpRequest 实例</li> <li>发出http请求</li> <li>接收服务器传回来的数据</li> <li>更新网页数据</li></ol> <p>与Ajax出生时不同的是，JSON格式已经替代了XML，除了HTTP请求支持file、ftp等</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 一旦实例的状态发生变化，就会调用监听函数</span>
  <span class="token comment">// 通信成功时，状态值为4</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 4，已接受或失败</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 状态码</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回的数据</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'/endpoint'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// open方法指定建立http连接的细节</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实际发送请求</span>
</code></pre></div><p>Ajax 只能向同源（协议、域名、端口都相同）网址发出请求，如果发出跨域请求，就会报错</p> <h3 id="xmlhttprequest-withcredentials"><a href="#xmlhttprequest-withcredentials" class="header-anchor">#</a> XMLHttpRequest.withCredentials</h3> <p>跨域请求时，用户信息是否包含在请求中。默认false。
如果跨域需要设置 withCredentials 为true。
为了让这个属性生效，服务器必须显式返回Access-Control-Allow-Credentials这个头信息。</p> <h3 id="cookie-storage"><a href="#cookie-storage" class="header-anchor">#</a> cookie storage</h3> <h3 id="location"><a href="#location" class="header-anchor">#</a> location</h3> <p>Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。</p> <table><thead><tr><th>属性</th> <th>描述</th></tr></thead> <tbody><tr><td>Location.href</td> <td>整个 URL</td></tr> <tr><td>Location.protocol</td> <td>当前 URL 的协议，包括冒号（:）</td></tr> <tr><td>Location.host</td> <td>主机。如果端口不是协议默认的80和433，则还会包括冒号（:）和端口</td></tr> <tr><td>Location.hostname</td> <td>主机名，不包括端口</td></tr> <tr><td>Location.port</td> <td>端口号</td></tr> <tr><td>Location.pathname</td> <td>URL 的路径部分，从根路径/开始</td></tr> <tr><td>Location.search</td> <td>查询字符串部分，从问号?开始</td></tr> <tr><td>Location.hash</td> <td>片段字符串部分，从#开始</td></tr> <tr><td>Location.username</td> <td>域名前面的用户名</td></tr> <tr><td>Location.password</td> <td>域名前面的密码</td></tr> <tr><td>Location.origin</td> <td>URL 的协议、主机名和端口</td></tr></tbody></table> <table><thead><tr><th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>document..location.assign(url)</td> <td>使得浏览器立刻跳转到新的 URL</td></tr> <tr><td>Location.replace(url)</td> <td>使得浏览器立刻跳转到新的 URL，替换掉当前页面的history记录</td></tr> <tr><td>Location.reload(Boolean)</td> <td>刷新，默认true向服务器请求，false 从本地缓存加载</td></tr> <tr><td>Location.toString()</td> <td>相当于 Location.href 属性</td></tr></tbody></table> <table><thead><tr><th>编码解析</th> <th>描述</th></tr></thead> <tbody><tr><td>encodeURI(完整的url)</td> <td>将元字符和语义字符之外的字符，都进行转义</td></tr> <tr><td>encodeURIComponent(URL片段)</td> <td>连元字符一起转义了，用来转义参数而不能整个url</td></tr> <tr><td>decodeURI()</td> <td>解码 encodeURI 的转码</td></tr> <tr><td>decodeURIComponent()</td> <td>解码 encodeURIComponent 的转码</td></tr></tbody></table> <blockquote><p>URL 元字符：分号（;），逗号（,），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）</p></blockquote> <blockquote><p>语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（'），圆括号（()）</p></blockquote> <p>除了以上字符，其他字符出现在 URL 之中都必须转义</p> <h3 id="url"><a href="#url" class="header-anchor">#</a> URL</h3> <p>URL接口是一个构造函数，浏览器原生提供，可以用来构造、解析和编码 URL。一般情况下，通过window.URL可以拿到这个构造函数</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">var</span> url1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'index.html'</span><span class="token punctuation">,</span> <span class="token string">'http://example.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
url1<span class="token punctuation">.</span>href
<span class="token comment">// &quot;http://example.com/index.html&quot;</span>

<span class="token keyword">var</span> url2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'page2.html'</span><span class="token punctuation">,</span> <span class="token string">'http://example.com/page1.html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
url2<span class="token punctuation">.</span>href
<span class="token comment">// &quot;http://example.com/page2.html&quot;</span>

<span class="token keyword">var</span> url3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'http://example.com/a/b.html'</span><span class="token punctuation">)</span>
url3<span class="token punctuation">.</span>href
<span class="token comment">// &quot;http://example.com/&quot;</span>
</code></pre></div><h2 id="存储"><a href="#存储" class="header-anchor">#</a> 存储</h2> <p>sessionStorage
locationStorage</p> <h2 id="多媒体元素接口"><a href="#多媒体元素接口" class="header-anchor">#</a> 多媒体元素接口</h2></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/bbzz/basicSystem/edit/master/docs/javaScript/webApi.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">8/5/2020, 9:43:58 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/basicSystem/javaScript/stdlib.html" class="prev">
        标准库
      </a></span> <span class="next"><a href="/basicSystem/javaScript/ES6.html">
        ES6+ 简要手册
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/basicSystem/assets/js/app.fe57eed6.js" defer></script><script src="/basicSystem/assets/js/3.40885dd2.js" defer></script><script src="/basicSystem/assets/js/52.7d8bbb55.js" defer></script>
  </body>
</html>
