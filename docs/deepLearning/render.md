# 06 浏览器渲染原理

接上篇，了解了 JS 运行机制再来看渲染流程水到渠成。

从一道网红题开始...

> 从输入 URL 到页面加载发生了什么?

这将是一篇长文，这个主题很合适用来梳理自己的知识体系。大致按照这个顺序进行：DNS 查询=》TCP 连接=》HTTP 请求=》服务器响应=》客户端渲染

## 1. 发送一个 HTTP 请求

#### 1.1 浏览器

浏览器进程包含：主进程（Browser 进程）、插件进程、GPU 进程、浏览器渲染进程（内核）。
渲染进程包含：GUI 线程、JS 引擎线程、事件触发线程、定时器线程、网络请求线程。

#### 1.2 解析 URL

输入 URL 后，会进行解析（URL 的本质就是统一资源定位符）

URL 一般包括几大部分：

- protocol，协议头，譬如有 http，ftp 等
- host，主机域名或 IP 地址
- port，端口号
- path，目录路径
- query，即查询参数
- fragment，即#后的 hash 值，一般用来定位到某个位置

#### 1.3 DNS 查询得到 IP

如果输入的是域名，需要进行 dns 解析成 IP，大致流程：

1. 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host
2. 如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP

- dns 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 dns-prefetch 优化

#### 1.4 客户端发起 HTTP 请求

内容太多了，单拎一篇讲。
HTTP 本质是 tcp/ip 请求。

tcp 将 http 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输。

##### 从应用层的发送 http 请求，到传输层通过三次握手建立 tcp/ip 连接，再到网络层的 ip 寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。

##### 三次握手：确认彼此身份

```HTML
客户端：hello，你是server么？
服务端：hello，我是server，你是client么
客户端：yes，我是client
```

##### 四次挥手：断开时，双方都要关闭通道

```HTML
主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
被动方：收到通道关闭的信息
被动方：那我也告诉你，我这边向你的主动通道也关闭了
主动方：最后收到数据，之后双方无法通信
```

##### tcp/ip 的并发限制

浏览器对同一域名下并发的 tcp 连接是有限制的

##### get 和 post 的区别

get 和 post 虽然本质都是 tcp/ip，但两者除了在 http 层面外，在 tcp/ip 层面也有区别。get 会产生一个 tcp 数据包，post 两个。

- get 请求时，浏览器会把 headers 和 data 一起发送出去，服务器响应 200（返回数据）
- post 请求时，浏览器先发送 headers，服务器响应 100 continue， 浏览器再发送 data，服务器响应 200（返回数据）

##### 五层因特网协议

1. 应用层(dns,http) DNS 解析成 IP 并发送 http 请求

2. 传输层(tcp,udp) 建立 tcp 连接（三次握手）

3. 网络层(IP,ARP) IP 寻址

4. 数据链路层(PPP) 封装成帧

5. 物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

## 2 服务器接收到请求

##### 负载均衡

反向代理服务器（nginx）

##### 后台处理

1. 一般有的后端是有统一的验证的，如安全拦截，跨域验证
2. 如果这一步不符合规则，就直接返回了相应的 http 报文（如拒绝请求等）
3. 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
4. 等程序执行完毕后，就会返回一个 http 响应包（一般这一步也会经过多层封装）
5. 然后就是将这个包从后端发送到前端，完成交互

##### 后台和前台的 http 交互

http 报文作为信息的载体

## 3. 解析渲染页面

浏览器内核（渲染进程）拿到 htpp 请求过来的内容后，渲染（GUI 线程）就开始工作了。

网上乱七八糟的解释信息太多了，尽量简明扼要说清楚。

#### 3.1 渲染流程

1. 将 HTML 解析为 DOM 树，
2. 将 CSS 解析为 CSSOM 树
3. DOM 树与 CSSOM 树合并后形成渲染树
4. 根据渲染树来布局，以计算每个节点的几何信息（Layout/Reflow）
5. 绘制渲染树，元素的像素信息（Paint）
6. GPU 将进行图层合成显示到屏幕上

##### 渲染流程图

<img :src="$withBase('/render1.png')" alt="渲染流程图">

##### 构建渲染树

<img :src="$withBase('/render2.png')" alt="形成渲染树的过程">

为构建渲染树，浏览器大体上完成了下列工作：

1. 从 DOM 树的根节点开始遍历每个可见节点。
   - 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。
   - 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点---不会出现在渲染树中，---因为有一个显式规则在该节点上设置了“display: none”属性。
   - visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。
2. 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。
3. 发送可见节点，连同其内容和计算的样式。

##### 布局

到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备视口内的确切位置和大小---这就是“布局”阶段，也称为“自动重排”。

<!--
5. 绘制Render树，绘制像素信息等（repaint）
6. 输出该层的位图, 位图存储在共享内存中, 作为纹理上传到GPU将多个位图合并，draw到屏幕上
7. 如果遇到。（这一过程叫阻塞渲染） -->

##### 绘制

将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。

##### Display

GPU 将多个位图合成, draw 到屏幕上。

#### 3.2 阻塞渲染的 CSS

在渲染树构建中，我们看到关键渲染路径要求我们同时具有 DOM 和 CSSOM 才能构建渲染树。

CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。

#### 3.3 阻塞渲染的 JavaScript

遇到 JS 就 UI 线程就挂起，JS 引擎执行完毕，再继续。

#### 3.4 文档流 与 盒模型

##### 盒模型

每个元素都是一个盒子，一个盒子包括了 宽高、内边距、边框、外边距。

- 标准盒模型：宽高只是内容（content）的宽高
- IE 盒模型：宽高是内容(content)+填充(padding)+边框(border)的总宽高，相当于标准盒子设置了 `box-sizing:border-box`;

##### 文档流

每个元素都是一个盒子按照顺序从左到右从上到下依次排开，像流水一样称之为文档流。

##### 脱离文档流

定位元素（absolute、fixed...）从原有位置独立出来，不再受周围元素影响，这种行为叫脱离文档流。

##### BFC

肯德基，大名：块级格式化上下文。

为啥老说 BFC，猜测 CSS 作为描述语言没啥深奥的为了凸现自己发明了个像闭包这样的词汇估计捉摸人。

> 盒模型有块级、行内、行内块，本来大家好好的相安无事。可是有一天你一个骚操作给自己搞了个浮动，一看，父级元素坍塌了后面的元素错乱了...当然也不是所有相安无事，你和楼下的小伙子互看不上眼，约定各自距离 10 公分，你俩骂骂咧咧都动了动，一看，咋还是 10 公分不是 20 公分么？

发现什么问题了吗？

> 你不是一个正儿八经的盒子了，简单来说没有了边界感。

BFC 干什么呢？

> 相当于一个透明的玻璃罩，把整个盒子框起来，里面随便折腾，从外面看跟个没事人一样。

满足下列条件之一就可触发 BFC

- 根元素，即 HTML 元素
- float 的值不为 none
- overflow 的值不为 visible
- display 的值为 inline-block、table-cell、table-caption
- position 的值为 absolute 或 fixed

##### IFC

好吧，我并不知道什么东西

#### 3.5 层合成 composite

层，是一个立体概念，元素上下堆砌形成一个个层空间，整个文档流是一个默认的复合图层。

GPU 中，各个复合图层是单独绘制的，所以互不影响。可以通过硬件加速开启一个新的复合图层，这也是 GPU 加速的由来。

开启方法：
translate3d、translateZ、opacity（动画过程中）、will-chang（opacity、transform、top、left、bottom、right）、`<video><iframe><canvas><webgl>`等元素

避坑：
使用硬件加速时，尽可能的使用 index，防止浏览器默认给后续的元素创建复合层渲染。

#### 3.6 重排

元素大小位置等几何信息改变时，可能影响父级元素及其他元素。脱离文档流只影响自己。

#### 3.7 重绘

不设计元素大小位置修改的其他属性，比如颜色等。重排一定重绘。
