# 前端性能优化

具体到前端性能优化这件事情上，我认为它是 20% 的理论，加上至少 80% 的实践，甚至很多理论本身也都是我们在具体的业务场景中实践出来的。所以希望大家阅读本章节时，能够读到一些“书本之外的东西”——最好是一边读一边回忆自己既有的开发经历，尝试去留意哪些知识是已知的，哪些是未知的。 这样读完之后，就可以有的放矢地把这些知识转换为自己的项目实践——前端技术日新月异，性能方案永远都在更迭，所以一定要形成自己的学习思路。 --- 修言

> 本文绝大内容修言老师的文章，谨以此文深表感谢！

::: tip 从一道经典面试题开始
从输入 URL 到页面加载完成，发生了什么？
:::

站在性能优化的角度，先简单复现一下这个过程：

1. DNS 解析：将要访问的 url 解析为 IP 地址
2. TCP 连接：与 IP 地址确定的服务器建立 TCP 连接
3. HTTP 请求：客户端发出 http 请求
4. HTPP 响应：服务端处理完数据，http 响应返回
5. 渲染展示：浏览器解析拿到的响应内容，渲染展示给用户

我们的性能优化紧紧围绕着 5 个步骤反复权衡优化方案，各个击破。

网络连接的必经之路的前两步，

> DNS 解析花时间能不能减少解析次数或者把解析前置？

-- 能，浏览器 DNS 缓存和 DNS 预解析

> TCP 每次的三次握手都急死人，有没有解决方案？

-- 有，长连接、预连接、接入 SPDY 协议

> 服务器越远，一次请求的时间就越慢，有没有办法？

-- 有，CDN 内容网络分发，静态资源部署在距离我们更近的 CDN 上

::: danger HTTP 请求/响应
DNS 和 TCP 往往需要服务端同学协作完成，前端可以做的努力也比较有限；但是，HTTP 请求/响应的两个方向，减少请求次数和减少请求体积，我们应该是专家！
:::

以上是网络层面的优化，接下来是浏览器端的性能优化

::: danger 浏览器优化
资源加载优化、服务端渲染、浏览器缓存机制的利用、DOM 树的构建、网页排版和渲染、回流与重绘的考量、DOM 操作的合理规避等，这正是我们前端可以一展拳脚的地方！
:::

## 网络

### 01. DNS 解析、TCP 连接、CDN 前端能做什么

1. DNS 预解析

   默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示 DNS Prefetch

```js
//用meta信息来告知浏览器, 当前页面要做DNS预解析
<meta http-equiv="x-dns-prefetch-control" content="on" />

// 在页面header中使用link标签来强制对DNS预解析:
<link rel="dns-prefetch" href="//www.zhix.net" />
```

2. TCP 连接
   长连接、管道化、http2.0，网络层面的工作均落在服务端同学身上。这一部分查看「计算机网络」章节

3. CDN

   CDN 的核心点有两个，一个是缓存，一个是回源；“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。

   将静态资源文件路径替换为 cdn 服务器地址

### 02. webpack 如何资源压缩与合并

1. 删除冗余代码

   Tree-Shaking

2. 按需加载

### 02. 图片有哪些优化手段

针对不同业务场景下的图片方案选型

- JPG
  > 有损压缩、体积小、加载快、不支持透明；具有丰富的色彩大幅压缩体积的仍能保持不错的品质；处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显
- PNG8 与 PNG24
  > 无损压缩、质量高、体积大、支持透明；PNG24 具有更丰富的色彩和支持半透明度，通常我更愿意用 PNG-24 图片，压缩后与 PNG8 相当
- SVG
  > 文本文件、体积小、不失真、兼容性好；SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式，可编程修改，具有较强的灵活性。
- IconFont
  > 一种字体文件，修改颜色、调整大小都非常灵活，但编辑成本较高
- Base64
  > 文本文件、依赖编码、小图标解决方案；通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。<br/>
  > 缺点也很明显，体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失。<br/>
  > 仅当在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计。这是 Base64 图优势所在。
- 雪碧图（CSS Sprites）
  > 图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。经典的小图标解决方案
- WebP
  > WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。<br/>
  > 唯一不足在于兼容性，把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。

## 存储

### 01. 浏览器缓存

缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段。

> 通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。

浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：

1. Memory Cache
2. Service Worker Cache
3. HTTP Cache（「计算机网络-缓存」章节）
4. Push Cache (http2 新特性)

> HTTP/2 PUSH 功能可以让服务器在没有相应的请求情况下预先将资源推送到客户端。这个跟 preload/prefetch 预加载资源的思路类似，将下载和资源实际执行分离的方法，当脚本真正想要请求文件的时候，发现脚本就存在缓存中，就不需要去请求网络了。

### 02. Cookie 有什么用

Cookie 的本职工作并非本地存储，而是“维持状态”。

HTTP 协议是一个无状态协议，服务器接收客户端的请求，返回一个响应，故事到此就结束了，服务器并没有记录下关于客户端的任何信息。Cookie 说白了就是一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。

Cookie 的性能劣势：

1. Cookie 不够大，当 Cookie 超过 4KB 时，它将面临被裁切的命运。
2. 过量的 Cookie 会带来巨大的性能浪费， Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie，这是一件多么劳民伤财的事情。

随着前端应用复杂度的提高，Cookie 也渐渐演化为了一个“存储多面手”——它不仅仅被用于维持状态，还被塞入了一些乱七八糟的其它信息，被迫承担起了本地存储的“重任”。在没有更好的本地存储解决方案的年代里，Cookie 小小的身体里承载了 4KB 内存所不能承受的压力。

为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。

### 03. Local Storage 与 Session Storage 的区别

Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 Local Storage 与 Session Storage。这两组概念非常相近，我们不妨先理解它们之间的区别，再对它们的共性进行研究

两者的区别在于生命周期与作用域的不同。

- **生命周期**：Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。

- **作用域**：Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。

Web Storage 的特性：

- 存储容量大： Web Storage 根据浏览器的不同，存储容量可以达到 5-10M 之间。

- 仅位于浏览器端，不与服务端发生通信。

Web Storage 核心 API：

```js
// 存储数据：setItem()
localStorage.setItem("user_name", "xiuyan");

// 读取数据： getItem()
localStorage.getItem("user_name");

// 删除某一键名对应的数据： removeItem()
localStorage.removeItem("user_name");

// 清空数据记录：clear()
localStorage.clear();
```

Local Storage 的应用场景：

Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。

这里给大家举个例子，考虑到 Local Storage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：

有的网站还会用它存储一些不经常更新的 CSS、JS 等静态资源。

Session Storage 的应用场景：

Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 Session Storage 就主要是存储你本次会话的浏览足迹

### 04. IndexedDB 有什么使用场景

IndexedDB 是一个运行在浏览器上的非关系型数据库，我们可以创建多个数据库，一个数据库中创建多张表，一张表中存储多条数据——这足以 hold 住复杂的结构性数据。IndexedDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，我们毫无疑问可以请出 IndexedDB 来帮忙。

1. 打开/创建一个 IndexedDB 数据库
2. 创建一个 object store
3. 构建一个事务来执行一些数据库操作，像增加或提取数据等
4. 通过监听正确类型的事件以等待操作完成

## 渲染

### 01. 服务端渲染的应用场景

服务端渲染本质上是本该浏览器做的事情，分担给服务器去做。这样当资源抵达浏览器时，它呈现的速度就快了。

我们把这么多台浏览器的渲染压力集中起来，分散给相比之下数量并不多的服务器，服务器肯定是承受不住的。

服务器稀少而宝贵，但首屏渲染体验和 SEO 的优化方案却很多——我们最好先把能用的低成本“大招”都用完。除非网页对性能要求太高了，以至于所有的招式都用完了，性能表现还是不尽人意，这时候我们就可以考虑向老板多申请几台服务器，把服务端渲染搞起来了

### 02. 浏览器背后的运行机制

浏览器内核可以分成两部分：`渲染引擎` 和 `JS 引擎`。

#### 浏览器渲染“黑盒”

HTML/CSS/JS => 浏览器内核 => 图像

浏览器内核有许多功能模块相互配合协同工作

- 渲染引擎
  - HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。
  - CSS 解释器：解析 CSS 文档, 生成样式规则。
  - 图层布局计算模块：布局计算每个对象的精确位置和大小。
  - 视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。
- JavaScript 引擎：编译执行 Javascript 代码

#### 页面首次渲染都要历经以下过程：

1. parseHtml 解析 html
   > 在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。
2. Style 计算样式
   > 浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）
3. Layout 计算图层布局
   > 页面中所有元素的相对位置信息，大小等信息均在这一步得到计算
4. Paint 绘制图层
   > 在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。
5. composite 合成图层成页面
   > 最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）

### 03. 为什么是"树"结构

在上一个过程中我们产生了

- DOM 树：解析 HTML 产生，DOM tree
- CSSOM 树：解析 css 创建的 CSSOM tree，CSSOM 的解析和 DOM 的解析是并行的
- 渲染树：CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）
- 布局渲染树：从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，我们便得到了基于渲染树的布局渲染树（Layout of the render tree）
- 绘制渲染树: 遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）

简而言之，首先是基于 html 构建一个 dom 树，这个 dom 树与 css 解释器解析出来的 cssom 树相结合，就有了布局渲染树，最后浏览器以布局渲染树为蓝本，去计算并绘制图像，这样页面的初次渲染就大功告成了。

第一个问题来了，**为什么是树**？

树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它具有以下的特点：

- 每个节点都只有有限个子节点或无子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；
- 树里面没有环路(cycle)

树 **结构稳定**，**查找效率高**，这也是为什么树在计算机有广泛应用的原因。

### 04. CSS 如何优化

1. 科学的书写 CSS 规则

在初次渲染结束后，每当一个新的元素加入到这个 dom 树中，浏览器会通过 CSS 引擎查询 CSS 样式表，找到符合该元素的规则应用到元素上，然后重新绘制它。

CSS 查询是一个费时的活，怎么让浏览器的查询工作又快又好地实现呢？

::: tip
CSS 引擎查找样式表，对每条规则都按 **从右到左** 的顺序去匹配
:::
我们至少可以总结出如下性能提升的方案：

- 避免使用通配符，只对需要用到的元素进行选择
- 关注可以通过继承实现的属性，避免重复匹配重复定义
- 少用标签选择器。如果可以，用类选择器替代
- id 和 class 选择器不应该被多余的标签选择器拖后腿
- 减少嵌套

```css
/* Bad Style */
#myList li {
}
.myList#title {
}
.a .b .c .d {
}
```

2.  告别阻塞：CSS 与 JS 的加载顺序优化

HTML、CSS 和 JS，都具有阻塞渲染的特性。

#### HTML 阻塞

> HTML 阻塞，天经地义——没有 HTML，何来 DOM？没有 DOM，渲染和优化，都是空谈

#### CSS 阻塞

DOM 和 CSSOM 合力才能构建渲染树，浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK。

> CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间

### 05. JS 的阻塞

JS 引擎是独立于渲染引擎存在的。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 因此与其说是 JS 把 CSS 和 HTML 阻塞了，不如说是 JS 引擎抢走了渲染引擎的控制权。

浏览器之所以让 JS 阻塞其它的活动，是因为它不知道 JS 会做什么改变，担心如果不阻止后续的操作，会造成混乱。

但是我们是写 JS 的人，我们知道 JS 会做什么改变。假如我们可以确认一个 JS 文件的执行时机并不一定非要是此时此刻，我们就可以通过对它使用 defer 和 async 来避免不必要的阻塞，这里我们就引出了外部 JS 的三种加载方式。

```JS
// 正常模式
<script src="index.js"></script>
// 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

// async 模式
<script async src="index.js"></script>
// JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行，这也表明 async 是轮序执行的。

// defer 模式
<script defer src="index.js"></script>
// defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发之前，被标记了 defer 的 JS 文件才会开始依次执行。
```

从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。

async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics

### 06. 为什么说操作 DOM 是昂贵的

我们知道，当 JS 登场时，往往意味着对 DOM 的操作。DOM 操作所导致的性能开销的“昂贵”，大家可能早就有所耳闻，雅虎军规里很重要的一条就是“尽量减少 DOM 访问”。

:::danger 昂贵的 DOM
那么 DOM 到底为什么慢，我们如何去规避这种慢呢？
:::

1. JS 引擎和渲染引擎的「过桥费」

> 把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》

JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在 JS 的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。

上一节我们提到，JS 引擎和渲染引擎（浏览器内核）是独立实现的。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。

我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。

2. DOM 的修改引发样式的更迭

过桥很慢，到了桥对岸，我们的更改操作带来的结果也很慢。

很多时候，我们对 DOM 的操作都不会局限于访问，而是为了修改它。当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发回流或重绘

这个过程本质上还是因为我们对 DOM 的修改触发了渲染树（Render Tree）的变化所导致的

- **回流**
  > 当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。
- **重绘**

  > 当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。

  重绘不一定导致回流，回流一定会导致重绘。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。

### 07. 如何规避回流与重绘

首先来看哪些实际操作会导致回流与重绘，要避免回流与重绘的发生，最直接的做法是避免掉可能会引发回流与重绘的 DOM 操作。

**重绘**

只要是不触发回流，但又触发了样式改变的 DOM 操作，都会引起重绘，比如背景色、文字色、可见性(可见性这里特指形如 visibility: hidden 这样不改变元素位置和存在性的、单纯针对可见性的操作，注意与 display:none 进行区分)等。

**回流**

- 最“贵”的操作：改变 DOM 元素的几何属性
  > 当一个 DOM 元素的几何属性发生变化时，所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算，它会带来巨大的计算量
- “价格适中”的操作：改变 DOM 树的结构
  > 这里主要指的是节点的增减、移动等操作。浏览器引擎布局的过程，顺序上可以类比于树的前序遍历——它是一个从上到下、从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。
- 最容易被忽略的操作：获取一些特定属性的值

  > offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，你就要注意了！

  这些值有一个共性，就是需要通过**即时计算**得到。因此浏览器为了获取这些值，也会进行回流。

仅触发 Composite，不触发 layout 或 paint

- backface-visibility
- opacity
- perspective
- perspective-origin
- transfrom

对策：

1. 将“导火索”缓存起来，避免频繁改动
2. 避免逐条改变样式，使用类名去合并样式
3. 将 DOM “离线”，display:none 掉，处理完毕再显示出来

4. 浏览器自己做的优化 Flush 队列

> 因为现代浏览器是很聪明的。浏览器自己也清楚，如果每次 DOM 操作都即时地反馈一次回流或重绘，那么性能上来说是扛不住的。于是它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。

大家这里尤其小心这个“不得已”的时候。前面我们在介绍回流的“导火索”的时候，提到过有一类属性很特别，它们有很强的“即时性”。当我们访问这些属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队——这就是所谓的“不得已”时刻。具体是哪些属性值，我们已经在“最容易被忽略的操作”这个小模块介绍过了，此处不再赘述。

### 08. Event Loop 与 VUE 的异步更新策略

Vue 和 React 都实现了异步更新策略。虽然实现的方式不尽相同，但都达到了减少 DOM 操作、避免过度渲染的目的。我们将基于 Event Loop 机制，对 Vue 的异步更新策略作探讨。

#### Event Loop 中的“渲染时机”

事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列

一个完整的 Event Loop 过程可以概括为以下过程：

1. 初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。
2. 全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。
3. 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。
4. **执行渲染操作，更新界面**

当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择

#### vue 的异步更新策略

当我们使用 Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被批量触发。这就是异步更新。

异步更新的特性在于它**只看结果**，因此渲染引擎**不需要为过程买单**。

Vue 每次想要更新一个状态的时候，会先把它这个更新操作给包装成一个异步操作派发出去。这件事情，在源码中是由一个叫做 **nextTick** 的函数来完成的

Vue 中每产生一个状态更新任务，它就会被塞进一个叫 callbacks 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 micro 或 macro 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 pending 锁是开着的（false），就把它设置为锁上（true），然后对当前 callbacks 数组的任务进行派发（丢进 micro 或 macro 队列）和执行。设置 pending 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。

## 应用

### 01. 优化首屏体验 - Lazy-Load

Lazy-Load，翻译过来是“懒加载”。它是针对图片加载时机的优化：在一些图片量比较大的网站（比如电商网站首页，或者团购网站、小游戏首页等），如果我们尝试在用户打开页面的时候，就把所有的图片资源加载完毕，那么很可能会造成白屏、卡顿等现象，因为图片真的太多了，一口气处理这么多任务，浏览器做不到啊！

但我们再想，用户真的需要这么多图片吗？不对，用户点开页面的瞬间，呈现给他的只有屏幕的一部分（我们称之为首屏）。只要我们可以在页面打开的时候把首屏的图片资源加载出来，用户就会认为页面是没问题的。至于下面的图片，我们完全可以等用户下拉的瞬间再即时去请求、即时呈现给他。这样一来，性能的压力小了，用户的体验却没有变差——这个延迟加载的过程，就是 Lazy-Load。

```JS
// 获取所有的图片标签
const imgs = document.getElementsByTagName('img')
// 获取可视区域的高度
const viewHeight = window.innerHeight || document.documentElement.clientHeight
// num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出
let num = 0
function lazyload(){
    for(let i=num; i<imgs.length; i++) {
        // 用可视区域高度减去元素顶部距离可视区域顶部的高度
        let distance = viewHeight - imgs[i].getBoundingClientRect().top
        // 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出
        if(distance >= 0 ){
            // 给元素写入真实的src，展示图片
            imgs[i].src = imgs[i].getAttribute('data-src')
            // 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出
            num = i + 1
        }
    }
}
// 监听Scroll事件
window.addEventListener('scroll', lazyload, false);
```

然而，这个 scroll 事件，是一个危险的事件——它太容易被触发了。试想，用户在访问网页的时候，是不是可以无限次地去触发滚动？尤其是一个页面死活加载不出来的时候，疯狂调戏鼠标滚轮（或者浏览器滚动条）的用户可不在少数啊！这里就引出了我们下一节的两位主角——throttle 与 debounce。

### 02. 事件的节流（throttle）

其实不止 scroll 事件，resize 事件、鼠标事件（比如 mousemove、mouseover 等）、键盘事件（keyup、keydown 等）都存在被频繁触发的风险。频繁触发回调导致的大量计算会引发页面的抖动甚至卡顿。为了规避这种情况，我们需要一些手段来控制事件被触发的频率。

“节流”与“防抖”的本质：

- 这两个东西都以闭包的形式存在
- 它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。

```JS
// fn是我们需要包装的事件回调, interval是时间间隔的阈值
function throttle(fn, interval) {
  // last为上一次触发回调的时间
  let last = 0

  // 将throttle处理结果当作函数返回
  return function () {
      // 保留调用时的this上下文
      let context = this
      // 保留调用时传入的参数
      let args = arguments
      // 记录本次触发回调的时间
      let now = +new Date()

      // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值
      if (now - last >= interval) {
      // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调
          last = now;
          fn.apply(context, args);
      }
    }
}

// 用throttle来包装scroll的回调
const better_scroll = throttle(() => console.log('触发了滚动事件'), 1000)

document.addEventListener('scroll', better_scroll)
```

### 03. 事件的防抖（debounce）

Debounce： 最后一个人说了算

```JS
// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间
function debounce(fn, delay) {
  // 定时器
  let timer = null

  // 将debounce处理结果当作函数返回
  return function () {
    // 保留调用时的this上下文
    let context = this
    // 保留调用时传入的参数
    let args = arguments

    // 每次事件被触发时，都去清除之前的旧定时器
    if(timer) {
        clearTimeout(timer)
    }
    // 设立新定时器
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, delay)
  }
}

// 用debounce来包装scroll的回调
const better_scroll = debounce(() => console.log('触发了滚动事件'), 1000)

document.addEventListener('scroll', better_scroll)
```

用 Throttle 来优化 Debounce，加强版的 Debounce

debounce 的问题在于它“太有耐心了”。试想，如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。

```JS
// fn是我们需要包装的事件回调, delay是时间间隔的阈值
function throttle(fn, delay) {
  // last为上一次触发回调的时间, timer是定时器
  let last = 0, timer = null
  // 将throttle处理结果当作函数返回

  return function () {
    // 保留调用时的this上下文
    let context = this
    // 保留调用时传入的参数
    let args = arguments
    // 记录本次触发回调的时间
    let now = +new Date()

    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值
    if (now - last < delay) {
    // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器
       clearTimeout(timer)
       timer = setTimeout(function () {
          last = now
          fn.apply(context, args)
        }, delay)
    } else {
        // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应
        last = now
        fn.apply(context, args)
    }
  }
}

// 用新的throttle包装scroll的回调
const better_scroll = throttle(() => console.log('触发了滚动事件'), 1000)

document.addEventListener('scroll', better_scroll)
```

## 性能监控

### 01. 可视化监测 - Performance 面板

Performance 面板是 Chrome 提供给我们的开发者工具，用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。

先看 CPU 图表和 Summary 饼图。CPU 图表中，我们可以根据颜色填充的饱满程度，确定 CPU 的忙闲，进而了解该页面的总的任务量。而 Summary 饼图则以一种直观的方式告诉了我们，哪个类型的任务最耗时（从本例来看是脚本执行过程）。这样我们在优化的时候，就可以抓到“主要矛盾”，进而有的放矢地开展后续的工作了。

再看 Main 提供给我们的火焰图。这个火焰图非常关键，它展示了整个运行时主进程所做的每一件事情（包括加载、脚本运行、渲染、布局、绘制等）。

CPU 图标和 Summary 图都是按照“类型”给我们提供性能信息，而 Main 火焰图则将粒度细化到了每一个函数的调用。到底是从哪个过程开始出问题、是哪个函数拖了后腿、又是哪个事件触发了这个函数，这些具体的、细致的问题都将在 Main 火焰图中得到解答。

Performance 无疑可以为我们提供很多有价值的信息，但它的展示作用大于分析作用。它要求使用者对工具本身及其所展示的信息有充分的理解，能够将晦涩的数据“翻译”成具体的性能问题。

### 02. 可视化监测 - 聪明的 LightHouse

Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为 Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。

### 03. 可编程的性能上报方案 - W3C 性能 API

W3C 规范为我们提供了 Performance 相关的接口。它允许我们获取到用户访问一个页面的每个阶段的精确时间，从而对性能进行分析。我们可以将其理解为 Performance 面板的进一步细化与可编程化。

`window.performance.timing`

```JS
const timing = window.performance.timing
// DNS查询耗时
timing.domainLookupEnd - timing.domainLookupStart

// TCP连接耗时
timing.connectEnd - timing.connectStart

// 内容加载耗时
timing.responseEnd - timing.requestStart

// firstbyte：首包时间
timing.responseStart - timing.domainLookupStart

// fpt：First Paint Time, 首次渲染时间 / 白屏时间
timing.responseEnd - timing.fetchStart

// tti：Time to Interact，首次可交互时间
timing.domInteractive - timing.fetchStart

// ready：HTML 加载完成时间，即 DOM 就位的时间
timing.domContentLoaded - timing.fetchStart

// load：页面完全加载时间
timing.loadEventStart - timing.fetchStart
```

## 开发环境

### 01. 开发环境如何优化

webpack 优化套路：
核心思路就那几条：加缓存，搞并行，提前做，少执行。

以上都是从生产环境，让我们的产品网页更快抵达用户，提升用户体验。

同时，我们在开发环境依然有很多工作要做，来提升开发效率
