# 计算机网络

## 网络协议

### 01. 7 层网络协议

七层网络协议（OSI）包含：

七层网络协议是理想的网络模型

1. 物理层
   > 为上层协议提供一个传输数据的物理媒体
2. 数据链路层
   > 负责物理层面的互联，节点间的通信传输
3. 网络层
   > 负责寻找地址和路由选择，协议：IP、IPX、RIP、OSPF 等
4. 传输层
   > 是最关键的一层，是唯一负责整体的数据传输和数据控制的，协议：TCP、UDP 等
5. 会话层
   > 控制应用程序的会话能力，它定义了一段会话的开始、控制和结束，包括对多个双向消息的控制和管理，以便在只完成一部分消息时可以通知应用。
6. 表示层
   > 这一层的主要作用是定义数据格式和加密
7. 应用层
   > 它是与其他计算机进行通信的应用，它是对应应用程序的通信服务的。各种应用软件，包括 web 应用； DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS

### 02. 4 层网络协议（TCP/IP 网络模型）

- TCP/IP 模型是互联网的基础
- TCP/IP 是互联网相关协议的统称，包含：TCP，DUP，IP，FTP，HTTP，SMTP 等等协议。

1. 链路层：负责用来处理连接网络的硬件部分，封装和解封装 IP 报文，发送和接受 ARP/RARP 报文等。
2. 网络层：负责独立于硬件的逻辑寻址,实现物理地址与逻辑地址的转换。
3. 传输层：负责对报文进行分组和重组，并以 TCP 或 UDP 协议格式封装报文。
4. 应用层：负责向用户提供应用程序，比如 HTTP、DNS、FTP、Telnet、SMTP 等。

### 03. TCP 是什么

TCP 是一种面向有连接、安全可靠的、基础字节流的传输控制协议。

TCP 特点有：

1. 面向连接
   > 在发送数据之前，双方需要建立连接，才能进行数据的正常发送
2. 仅支持点对点传输
   > 每条 TCP 传输只能在两个端点，只能进行点对点的单播传输，不支持多播和广播
3. 面向字节流
   > TCP 不像 UDP 那样一个报文一个报文独立传输，而是在不保存报文边界的情况下以字节流的形式传输
4. 可靠性
   > CP 为了保证传输的可靠性给每一个包一个序号，同时也保证了传输到接收方的包是按序排列。接收方对于已经接受的包会回传一个相应的确认（ACK），如果发送方在确认的往返时延（RTT）没有收到确认，就会重新发送
5. 提供阻塞控制
   > 当网络出现阻塞的时候，TCP 会减少发送数量和发送速率
6. 全双工
   > TCP 允许通信的双方应用程序在任何时候发送数据，因为 TCP 在两端都设有缓存，来存放临时通信数据。TCP 可以马上发送数据段，也可以缓存等待一段时候在发数据段，以便一次发送更多的数据（最大的数据段取决于 MSS）

### 04. TCP / UDP 的区别

| TCP                  | UDP                   |
| -------------------- | --------------------- |
| 定义：传输控制协议   | 定义：用户数据报协议  |
| 面向连接的协议       | 无连接协议            |
| 建立连接通道         | 把数据打包            |
| 数据大小无限制       | 数据大小有限制（64k） |
| 速度慢，但是可靠性高 | 速度快，但可靠性低    |
| 端对端传输           | 多种传输方式          |

1. UDP 面向无连接，发送数据之前不需要像 TCP 一样需要 3 次握手建立链接
2. 所以具备不可靠性
3. 具有高效性，不需要 TCP 那么复杂，不需要保证数据的准确到达，不需要重发，不考虑数据丢包
4. TCP 不仅支持一对一，还支持一对多、多对多、多对一的传输方式
5. 面向报文

### 05. TCP 如何保障通信的可靠性

全双工模式

- TCP 连接 三次握手

  1. 为了保证`服务端`接受到了`客户端`的信息并做出了应答，而 进行前两次握手（1&2 次 握手）
  2. 为了保证`客户端`接受到了`服务端`的嘻嘻并做出了应答，而 进行了后两次握手（2&3 次 握手）

  > 这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值。所以三次握手不是 TCP 本身的要求, 而是为了满足"在不可靠信道上可靠地传输信息

  握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

- TCP 断开 四次挥手

  > 和三次握手的道理是一样的

- 数据包
  1. 应用层（http、dns） - 传输层（tcp） - 网络层（ip） - 链路层 => 这个过程中层层添加部首
  2. 链路层 - 网络层 - 传输层 - 应用层 => 这个过程中层层删除部首

### 05. DNS 的作用什么，如何优化网络

处于 TCP/IP 网络模型的应用层，将域名解析为对应的 IP 地址。

浏览器对网站第一次的域名 DNS 解析查找流程依次为：
浏览器缓存-系统缓存-路由器缓存-ISP DNS 缓存-递归搜索

```JS
// 可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析
<meta http-equiv="x-dns-prefetch-control" content="on" />
// 使用link标签来强制对DNS做预解析
<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
<link rel="dns-prefetch" href="http://nsclick.baidu.com" />
```

### 06. CDN 是什么，有什么优势

CDN 是内容分发网络。

通常我们将动态内容放到跟服务器，静态资源放在 CDN 中，以便就近拉取资源最大化减少传输时间

CDN 回源是什么意思？

当 cdn 缓存服务器中没有符合客户端要求的资源的时候，缓存服务器会请求上一级缓存服务器，以此类推，直到获取到。最后如果还是没有，就会回到我们自己的服务器去获取资源。 那都有哪些时候会回源呢？没有资源，资源过期，访问的资源是不缓存资源等都会导致回源

资源的过期如何判定？cdn 是如何更新数据的？

资源过期时间就是根据我们老生常谈的请求头部来判定。这个后面会单拎出一篇文章带大家复习一下。
那么 cdn 是如何更新数据的？分两种，主动（PUSH）和被动（PULL）。被动刚才我们已经提到过了，利用回源就可以被动在途经的 cdn 节点缓存数据。 而主动指的是，我们从服务器主动往 cdn 推送数据。

### 07. URL、 URI、 URN 的区别

| URI            | URL            | URN          |
| -------------- | -------------- | ------------ |
| 统一资源标识符 | 统一资源定位符 | 统一资源名称 |

eg：

> 去寻找一个具体的人（URI）；<br/>
> 如果用地址：XX 省 XX 市 XX 区...XX 单元 XX 室的主人 就是 URL；<br/>
> 如果用身份证号+名字去找就是 URN（身份证号+名字 无法确认资源的地址）

一个 url 的格式：

> http://user:password@www.example.com:80/index.html/?uid=1#fragment

协议 + 登录信息 + 服务器地址 + 服务器端口 + 文件路径 + 参数 + 片段

## HTTP

HTTP 协议即超文本传送协议(Hypertext Transfer Protocol )，是 Web 联网的基础，也是手机联网常用的协议之一，HTTP 协议是建立在 TCP 协议之上的一种应用。

### 01. HTTP 1.0/1.1/2.0 版本有何区别

- HTTP/1.0，最早的 http 只是使用在一些较为简单的网页上和网络请求上，所以比较简单，每次请求都打开一个新的 TCP 链接，收到响应之后立即断开连接。

- HTTP/1.1:

  1. HTTP/1.1 引入了更多的缓存控制策略，如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等
  2. HTTP/1.1 允许范围请求，即在请求头中加入 Range 头部
  3. HTTP/1.1 默认开启持久连接（长连接 keep-alive），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟
  4. 管道化持久连接
     ![img](https://user-gold-cdn.xitu.io/2019/5/14/16ab4ec30a0062a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- HTTP/2.0
  [HTTP/2](https://www.cnblogs.com/yingsmirk/p/5248506.html)

  1. 二进制分帧
     > 在不改变 Http 内容前提下，将 Http 报文内容封装到不同帧中，以更小的形式进行传递。改善传输性能。
  2. 多路复用

     > 多个请求共享同个连接，避免队头阻塞（head of line blocking）问题。同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。单个连接上可以并行交错的请求和响应，之间互不干扰。

     > HTTP/2 的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

     - 通域名下的所有通信都在单个连接上完成
     - 单个链接可以承接任意数量的数据流
     - 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装

  3. header 压缩
     > 减少请求内容，提升传输速度
  4. 服务端推送

::: tip
简而概之，HTTP/2 的通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP 首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。

HTTP/2 性能得到了极大的提升，我们在 HTTP 1.1 时代做的有些优化反而成了鸡肋，在升级过程中，如何让 HTTP/2 和 HTTP 1.1 的用户都能得到最优的性能，这是对于我们的另外一大挑战。
:::

### 02. HTTP 报文结构是怎样的

对于 TCP 而言，在传输的时候分为两个部分：TCP 头和数据部分。

而 HTTP 类似，也是 `header` + `body` 的结构，具体而言:

> 起始行 + 头部 + 空行 + 实体

| title        | 请求报文                        | 响应报文                        |
| ------------ | ------------------------------- | ------------------------------- |
| 起始行       | 请求行：方法 + 路径 + http 版本 | 响应行：http 版本、状态码和原因 |
| 头部         | 请求头                          | 响应头                          |
| 空行         |                                 |                                 |
| 实体（body） | 请求体                          | 响应体                          |

### 03. HTTP 有哪些请求方法

1. GET：通常用来获取资源
2. HEAD：获取资源的元信息
3. POST：提交数据，即上传数据
4. PUT：修改数据
5. DELETE：删除资源(几乎用不到)
6. CONNECT：建立连接隧道，用于代理服务器
7. OPTIONS：列出可对资源实行的请求方法，用来跨域请求
8. TRACE：追踪请求-响应的传输路径

比较常用是前四种。

### 04. HTTP 中 GET 与 POST 的区别

|        | GET                                | POST                                                                       |
| ------ | ---------------------------------- | -------------------------------------------------------------------------- |
| 语义   | 一般用于获取服务器资源             | 一般用于传输实体主体                                                       |
| 缓存   | 被浏览器主动缓存下来，留下历史记录 | 不会                                                                       |
| 编码   | 只能进行 URL 编码                  | 无限制                                                                     |
| 安全   | 参数直接暴露在 url 中              | 参数放在请求体中，仅仅相对安全一点；基于 http 的明文传输，并无实际安全可言 |
| 副作用 | get 请求时幂等，无副作用           | 多次请求的值可能并不相同                                                   |

> 幂等：表示执行相同的操作，结果也是相同的

### 05. HTTP 状态码分别是什么意思

- 1XX：表示目前是协议处理的中间状态，还需要后续操作
- 2XX：表示成功状态
  - 200：最常见的成功状态
  - 204：响应头后没有 body 数据
  - 206：通常出现在分块下载或断点续传中
    > 类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
- 3XX：表示重定向，资源位置发生变动，需要重新请求
  - 301： 永久重定向
    > 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
  - 302：临时重定向
    > 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。
  - 304：协商缓存命中时返回 304
    > 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
    > ![img](https://img20.360buyimg.com/ling/jfs/t1/59428/40/2154/46331/5d077c6fE766c1e12/21aa5bbc502b6c5c.png)
- 4XX：表示客户端请求错误，一般是报文错误
  - 400：比较笼统的错误提示
  - 401: 需要用户验证
  - 403：服务器禁止客户端访问
  - 404：资源未找到
  - 405：请求方法不被服务端允许
  - [HTTP 响应代码 ... MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)
- 5XX：表示服务端错误
  - 500：服务端出错，比较笼统的提示
  - 501：客户端请求的功能还不支持
  - 502：服务器自身正常，但访问出错了，啥原因不知道
  - 503：服务器比较忙，暂时无法响应

### 06. HTTP 有哪些特点 及 缺点

HTTP 特点：

1. 灵活可扩展
   > 一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便
2. 可靠传输
   > HTTP 基于 TCP/IP，因此把这一特性继承了下来
3. 请求-应答，有来有回
   > 也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色
4. 无状态
   > 这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息

HTTP 缺点：

1. 无状态

   > 所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。<br>
   > 在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。<br>
   > 但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

2. 明文传输

   > 即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。<br/>
   > 这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI 陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。

3. 队头阻塞问题

   > 当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。

### 07. HTTP 的队头阻塞问题如何解决

1. 并发连接，chrome 中单个域名最多可以并发 6 个长连接
2. 域名分片，多划分几个域名，提高长连接并发数

HTTP 协议头部与 Keep-Alive 模式详解
HTTP keep-alive 二三事

### 08. HTTP 代理有什么用

引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。

代理服务器，用来做什么呢？

1. 负载均衡
   > 客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性 hash、LRU(最近最少使用)等等
2. 保障安全
   > 利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。
3. 缓存代理
   > 将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。

### 09. HTTPS 如何保障通信的安全性

HTTPS 称为超文本传输安全协议，经由 HTTP 进行通信，利用 TLS/SSL 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

参考：[一个故事](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)

Client- 请求公钥 ->Server—公钥+数字签名—>Client- 1.验证证书-2.生成随机对称密钥-3.利用服务端的公钥加密对称密钥-4.发送加密后的对称密钥->Server

### 10. cookie 和 session 有什么区别

Cookie 的出现，是为了辨别用户身份而储存在用户本地终端上的数据，解决客户端与服务端会话状态的问题，因为『HTTP 是一个无状态的协议』

Cookie 主要用于以下三个方面

1. 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
2. 个性化设置（如用户自定义设置、主题等）
3. 浏览器行为跟踪（如跟踪分析用户行为等）

那 Cookie 是怎么设置的呢？简单来说就是：

1. 客户端发送 HTTP 请求到服务器
2. 当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段
3. 浏览器收到响应后保存下 Cookie
4. 之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。

Cookies 的属性有：

- Name/Value ：用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理
- Expires： 设置 Cookie 的过期时间
- Max-Age 在 Cookie 失效之前需要经过的秒数
- Domain 指定了 Cookie 可以送达的主机名
  > 像淘宝首页设置的 Domain 就是 .taobao.com，这样无论是 a.taobao.com 还是 b.taobao.com 都可以使用 Cookie<br/>
  > 不能跨域设置 Cookie，比如阿里域名下的页面把 Domain 设置成百度是无效的
- Path: Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部
  > Domain 和 Path 标识共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 UR
- Secure： 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。
- HTTPOnly：设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击
- SameSite：之前默认是 None 的，Chrome80 后默认是 Lax
  1.  Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。
  2.  Lax 允许部分第三方请求携带 Cookie
  3.  None 无论是否跨站都会发送 Cookie

#### session 认证流程

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器

浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名

当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取

SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。

#### Cookie 和 Session 的区别

- 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

### 11. 了解过 jwt/用户 token 的生成和使用吗

- JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案
- 是一种认证授权机制
- JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上
- 可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的

#### JWT 认证流程：

用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT
客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）
当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样

```JS
Authorization: Bearer <token>
```

#### 特点

- 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为
- 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要
- 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
- 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制

### 12. 谈谈 Cookie 和 SameSite 属性

SameSite 可以有下面三种值：

1. Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。
2. Lax 允许部分第三方请求携带 Cookie
3. None 无论是否跨站都会发送 Cookie

之前默认是 None 的，Chrome80 后默认是 Lax。

![img](https://camo.githubusercontent.com/149e5a3d4eadf8a9f19f26ffc5de5a5f37a62da4/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423172473448794b4832674b306a535a4645585863714d7058612d313430302d3532382e706e67)

从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。

- Post 表单：应该的，学 CSRF 总会举表单的例子。

- iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。

- AJAX：可能会影响部分前端取值的行为和结果。

- Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受到影响。

除了这些还有 script 的方式，这种方式也不会发送 Cookie，像淘宝的大部分请求都是 jsonp，如果涉及到跨站也有可能会被影响。

影响：

1. 淘宝部分页面内嵌支付宝确认付款和确认收货页面、天猫内嵌淘宝的登录页面等，由于 Cookie 失效，付款、登录等操作都会失败
2. 阿里妈妈在各大网站比如今日头条，网易，微博等投放的广告，也是用 iframe 嵌入的，没有了 Cookie，就不能准确的进行推荐
3. 一些埋点系统会把用户 id 信息埋到 Cookie 中，用于日志上报，这种系统一般走的都是单独的域名，与业务域名分开，所以也会受到影响。

解决方案就是设置 SameSite 为 none。

如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。

### 13. 介绍 HTTPS 握手过程

1.  客户端使用 https 的 url 访问 web 服务器,要求与服务器建立 ssl 连接
2.  web 服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
3.  客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
4.  客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
5.  之后服务器与客户端使用秘钥加密传输

### 14. HTTPS 握手过程中，客户端如何验证证书的合法性

1. 首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内
2. 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发
3. 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
4. 如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥(多数浏览器开发商发布 版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密
5. 浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比
6. 对比结果一致，则证明服务器发来的证书合法，没有被冒充

### 15. 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响

从搜索引擎优化角度出发，301 重定向是网址重定向最为可行的一种办法。当网站的域名发生变更后，搜索引擎只对新网址进行索引，同时又会把旧地址下原有的外部链接如数转移到新地址下，从而不会让网站的排名因为网址变更而收到丝毫影响。

### 16. 接口如何防刷

1. 总调用次数受限制。这个一般是在后端做限制，单位时间内最多可调用次数。
2. 同一客户端次数限制。这个前端的一般使用是给接口调用加锁，在返回结果或者一定时间之后解锁。

### 17. 为什么 HTTP1.1 不能实现多路复用

HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

### 18. 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片

1. 避免跨域（img 天然支持跨域）
2. 利用空白 gif 或 1x1 px 的 img 是互联网广告或网站监测方面常用的手段，简单、安全、相比 PNG/JPG 体积小，1px 透明图，对网页内容的影响几乎没有影响，这种请求用在很多地方，比如浏览、点击、热点、心跳、ID 颁发等等，
3. 图片请求不占用 Ajax 请求限额
4. 不会阻塞页面加载，影响用户的体验，只要 new Image 对象就好了，一般情况下也不需要 append 到 DOM 中，通过它的 onerror 和 onload 事件来检测发送状态。 示例：

```JS
 var thisPage = location.href;
 var referringPage = (document.referrer) ? document.referrer : "none";
 var beacon = new Image();
 beacon.src = "http://www.example.com/logger/beacon.gif?page=" + encodeURI(thisPage)
 + "&ref=" + encodeURI(referringPage);
```

## HTTP 缓存

### 01. 尽可能详细的介绍 http 缓存

HTTP 缓存分为两种，强制缓存 and 协商缓存，目的为了加快资源获取速度，减少网络传输，缓解服务器压力。是前端工程师必要掌握的重点知识之一。
![缓存运作流程图](https://user-gold-cdn.xitu.io/2020/5/10/171fea0fec0b4668?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
[图解 Http 缓存](https://juejin.im/post/5eb7f811f265da7bbc7cc5bd)
[浏览器缓存-详细](https://github.com/xiangxingchen/blog/issues/9)

#### 强缓存

不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 `Expires`、`Cache-Control` 和 `Pragma` 3 个 Header 属性共同来控制

1.  Expires
    > Expires（过期） 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。
2.  Cache-Control

    > 在请求头和响应头中都可以使用，常用的属性值如有：

    1.  max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效
    2.  no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜，在与服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。
    3.  no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源
    4.  private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应
    5.  public：响应可以被中间代理、CDN 等缓存
    6.  must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证

3.  Pragma

    > Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。

#### 协商缓存

当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。

1. ETag/If-None-Match

> ETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash 码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 "W/" 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。

2. Last-Modified/If-Modified-Since

> Last-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。

![img](https://user-gold-cdn.xitu.io/2018/1/27/16137f262e0adf18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 02. 请求被缓存，新代码未生效怎么办

1. 服务端响应添加 Cache-Control:no-cache,must-revalidate 指令；
1. 修改请求头 If-modified-since:0 或 If-none-match；
1. 修改请求 URL，请求 URL 后加随机数，随机数可以是时间戳，哈希值，比如：damonare.cn?a=1234

## 跨域

### 01. 跨域问题是怎么产生的，如何解决

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。所谓同源是指"协议+域名+端口"三者相同。

同源策略限制的内容有：

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求

允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

跨域的方案有：

1. JSONP
   > 利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求需要对方的服务器做支持才可以，仅支持 get 方法。

```JS
// index.html
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script')
    window[callback] = function(data) {
      resolve(data)
      document.body.removeChild(script)
    }
    params = { ...params, callback } // wd=b&callback=show
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(script)
  })
}
jsonp({
    url: 'http://localhost:3000/say',
    params: { wd: 'Iloveyou' },
    callback: 'show'
  }).then(data => {
    console.log(data)
})
```

2. postMessage

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的 iframe 消息传递
- 上面三个场景的跨域数据传递

3. nginx 反向代理

   最简单的跨域方式

4. Cors

CORS 需要浏览器和后端同时支持。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

```JS
// Server 设置
Access-Control-Allow-Origin 设为 *
```

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

满足 （get || post || head）&&（text/plain || multipart/form-data || application/x-www-form-urlencoded）既为简单请求，否则就是复杂请求

复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求,该请求是 `option` 方法的，通过该请求来知道服务端是否允许跨域请求。

5. WebSocket

HTML5 开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于 TCP 传输协议，并复用 HTTP 的握手通道。
支持双向通信，实时性更强。

1. 更好的二进制支持。
2. 较少的控制开销。连接创建后，ws 客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有 2~10 字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的 4 字节的掩码。而 HTTP 协议每次通信都需要携带完整的头部。
3. 支持扩展。ws 协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）

```js
var ws = new WebSocket("ws://localhost:8080");
ws.onopen = function() {
  console.log("ws onopen");
  ws.send("from client: hello");
};
ws.onmessage = function(e) {
  console.log("ws onmessage");
  console.log("from server: " + e.data);
};
```

## 安全

### 01. XSS

XSS（Cross Site Script）跨站脚本攻击，通过对网页注入可执行代码，成功地被浏览器执行,达到攻击的目的。有两种类型:

- 存储型：将脚本作为数据存到服务器，其他用户读取时执行

- 反射型：在 get 请求的 url 里输入脚本语句

如何防范：

- 对输入内容做不可信处理，采取过滤、转义等处理
- 增加 httpOnly，避免 cookie 信息的截取

```JS
// 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息
ctx.cookies.set(name, value, {
      httpOnly: true // 默认为 true
  })
```

### 02. CSRF

CSRF（Cross Site Request Forgery）跨站请求伪造，通常伪造网站信息（比如，用户已登录的 cookie 信息），在用户不知情的情况下骗取服务端信任，从而进行某些操作。

网站过分相信用户，给了攻击者模拟用户操作的机会。

如何防范：

- 表单生成 tocken 放入 cookie 或者 session(所有表单都包含同一个伪随机值)，服务端进行 hash 值验证
- 验证码，用户加上图片生成的验证码

### 03. 点击劫持

点击劫持是指在一个 Web 页面中隐藏了一个透明的 iframe，用外层假页面诱导用户点击，实际上是在隐藏的 frame 上触发了点击事件进行一些用户不知情的操作。

如何防范：

网站可以通过设置 X-Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持

### 04. 网络劫持攻击

使用 https
